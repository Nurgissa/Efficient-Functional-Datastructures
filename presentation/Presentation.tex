%------------------------------------------------------------------
% Präsentation "Suffix Trees und Suffix Arrays"
%------------------------------------------------------------------

% Autoren   : Simon Kaltenbacher, Evgeny Novoseltsev
% Semester  : WS 11/12
% Vorlesung : Effiziente funktionale Datenstrukturen
% Betreuer  : Prof. Martin Hofmann, PhD

% Latex Beamer Tutorial kann unter folgendem Link gefunden werden: http://www.math.umbc.edu/~rouben/beamer/quickstart-Z-H-18.html#node_sec_18

% Eine nützliche Sammlung von Beispielen für die Latex Beamer-Klasse kann unter folgendem Link gefunden werden: http://www.informatik.uni-freiburg.de/~frank/latex-kurs/latex-kurs-3/Latex-Kurs-3.html

\documentclass{beamer}
\usepackage[ngerman]{babel}
% Umlaute in Ausgabedokument anzeigen
\usepackage[T1]{fontenc}
% Kodierung festlegen$
%\usepackage{ucs}
\usepackage[utf8]{inputenc}
% Mathematische Notationen
\usepackage{amsmath, amsfonts, amssymb}
% Bäume zeichnen
\usepackage{tikz}

% Beamer Konfiguration
\usetheme{Goettingen}
%\usecolortheme{sidebartab}
%\useoutertheme{default}
\beamersetuncovermixins{\opaqueness<1>{25}}{\opaqueness<2->{15}}

\usetikzlibrary{trees, calc}

% Styledefinitionen für Suffix Trees
\tikzstyle{branch} = [shape = circle, minimum size = 1mm, inner sep = 0mm, outer sep = 0.5mm, fill]

% Titel
\title{Suffix Trees und Suffix Arrays}  

% Autoren
\author{Simon Kaltenbacher, Evgeny Novoseltsev}

% Erstellungsdatum
\date{\today}

% Dokument
\begin{document}

%------------------------------------------------------------------
% Titelfolie
%------------------------------------------------------------------

\frame{\titlepage}

%------------------------------------------------------------------
% Inhaltsverzeichnis
%------------------------------------------------------------------

\frame{\frametitle{Inhaltsverzeichnis}\tableofcontents}

%------------------------------------------------------------------
% Einführung
%------------------------------------------------------------------

\section{Einführung}
\begin{frame}
\frametitle{Titel}
Merged!
\end{frame}

%------------------------------------------------------------------
% Terminologie
%------------------------------------------------------------------

\section{Terminologie}

%------------------------------------------------------------------
% Suffix Tree Klassen
%------------------------------------------------------------------

\subsection{Suffix Tree Klassen}

\begin{frame}
\frametitle{Atomic Suffix Tree}
$ast$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                    child {
                                        node[branch]{}
                                        child {
                                            edge from parent
                                            node[left]{$g$}
                                        }
                                        edge from parent
                                        node[left]{$a$}
                                    }
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$c$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            edge from parent
            node[right]{$g$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$c$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            edge from parent
            node[left]{$g$}
        }
        edge from parent
        node[left]{$c$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$a$}
                            }
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$c$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[right]{$c$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Position Suffix Tree and Compact Suffix Tree}
$pst$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{cgag}
        }
        child {
            edge from parent
            node[right]{gcgacgag}
        }
        edge from parent
        node[above]{a}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent
                    node[left]{cgag}
                }
                child {
                    edge from parent
                    node[right]{g}
                }
                edge from parent
                node[left]{a}
            }
            edge from parent
            node[left]{g}
        }
        edge from parent
        node[left]{c}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                edge from parent
                node[left]{cgag}
            }
            child {
                node[branch]{}
                edge from parent
                node[right]{g}
            }
            edge from parent
            node[left]{a}
        }
        child {
            edge from parent
            node[right]{cgacgag}
        }
        edge from parent
        node[above]{g}
    };
\end{tikzpicture}
\end{figure}

$cst$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{cgag}
        }
        child {
            edge from parent
            node[right]{gcgacgag}
        }
        edge from parent
        node[above]{a}
    }
    child[level distance = 16mm] {
        node[branch]{}
        child {
            edge from parent
            node[left]{cgag}
        }
        child {
            edge from parent
            node[right]{g}
        }
        edge from parent
        node[left]{cga}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                edge from parent
                node[left]{cgag}
            }
            child {
                node[branch]{}
                edge from parent
                node[right]{g}
            }
            edge from parent
            node[left]{a}
        }
        child {
            edge from parent
            node[right]{cgacgag}
        }
        edge from parent
        node[above]{g}
    };
\end{tikzpicture}
\end{figure}
\end{frame}

%------------------------------------------------------------------
% wotd-Algorithmus: Schritte
%------------------------------------------------------------------

\section{wotd-Algorithmus}

\begin{frame}[t]
\frametitle{wotd-Algorithmus für cst}

    Write-only top-down construction for sufﬁx trees.\\

    \medskip

    Schritte:
    \begin{enumerate}
    \item Finde alle Siffixe vom gegebenen Wort.
    \item Gruppiere nach den Anfangsbuchstaben. Erzeuge einen Knoten.
    \item Für jede Gruppe:
    \begin{enumerate}
    \item Finde das längste gemeinsame Präfix, erzeuge eine Kante mit der Beschriftung vom Präfix, entferne das Präfix von Wörter der Gruppe.
    \item Falls die Gruppe leer ist, erzeuge ein Blatt und gehe zu der nächste Gruppe. Falls es in der Gruppe noch Wörter gibt, kehre zum Schritt 2 zurück.
    \end{enumerate} 
    \end{enumerate}

\end{frame}

%------------------------------------------------------------------
% wotd-Algorithmus: Beispiel
%------------------------------------------------------------------

\subsection{cst-Konstruktion für das Wort $agcgacgag$}

%------------------------------------------------------------------
% Beispiel: Schritt 1 und 2
%------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Schritt 1 und Schritt 2}

\begin{columns}

    \begin{column}[t]{0.47\textwidth}
        a g c g a c g a g   \\
        g c g a c g a g     \\
        c g a c g a g       \\
        g a c g a g         \\
        a c g a g           \\
        c g a g             \\
        g a g               \\
        a g                 \\
        g                   \\
    \end{column}

    \begin{column}[t]{0.47\textwidth}
        <Bild: der Wurzel.>
    \end{column}

\end{columns}

\medskip

\begin{columns}

    \begin{column}[t]{0.3\textwidth}
        1. Gruppe:          \\
        a g c g a c g a g   \\
        a c g a g           \\
        a g                 \\
    \end{column}

    \begin{column}[t]{0.3\textwidth}
        2. Gruppe:      \\
        g c g a c g a g \\
        g a c g a g     \\
        g a g           \\
        g               \\
    \end{column}

    \begin{column}[t]{0.3\textwidth}
        3. Gruppe:      \\
        c g a c g a g   \\
        c g a g         \\
    \end{column}

\end{columns}

\end{frame}

%------------------------------------------------------------------
% Beispiel: Schritt 3 für 1. Gruppe
%------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Schritt 3 für 1. Gruppe}
    a g c g a c g a g   \\
    a c g a g           \\
    a g                 \\

    \medskip

    Schritt 3.1: Das längste gemeinsame Präfix is $a$. Erzeuge eine Kante mit der Beschriftung $a$, entferne $a$ von Wörter der Gruppe:

    \medskip

    \begin{columns}

    \begin{column}[t]{0.3\textwidth}
        1'. Gruppe:     \\
        g c g a c g a g \\
        c g a g         \\
        g               \\
    \end{column}

    \begin{column}[t]{0.3\textwidth}
        <Bild: der Wurzel mit a-Kante.>
    \end{column}

\end{columns}

    \medskip

    Schritt 3.2: Die Gruppe ist nicht leer $\rightarrow$ Schritt 2:

    \begin{columns}

    \begin{column}[t]{0.3\textwidth}
        1.1 Gruppe:     \\
        g c g a c g a g \\
        g               \\
    \end{column}

    \begin{column}[t]{0.3\textwidth}
        1.2. Gruppe:    \\
        c g a g         \\
    \end{column}

\end{columns}

\end{frame}

%------------------------------------------------------------------
% Beispiel: 1.1 Gruppe bis zu Blätter
%------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Schritte für 1.1 Gruppe}

    \begin{columns}

        \begin{column}[t]{0.5\textwidth}

            1.1 Gruppe:     \\
            g c g a c g a g \\
            g               \\

            \medskip

            Präfix: $g$

        \end{column}

        \begin{column}[t]{0.5\textwidth}
            
            <Bild: Neue Kante mit $g$>

        \end{column}

    \end{columns}

    \bigskip

    \begin{columns}

        \begin{column}[t]{0.5\textwidth}

                1.1' Gruppe:    \\
                c g a c g a g   \\

                \medskip

                Präfix: $c g a c g a g$

        \end{column}

        \begin{column}[t]{0.5\textwidth}
            
             <Bild: Neue Kante mit $c g a c g a g$> 

        \end{column}

    \end{columns}

\end{frame}

%------------------------------------------------------------------
% Beispiel: 1.2 Gruppe bis zu Blätter
%------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Schritte für 1.2 Gruppe}

    \begin{columns}

        \begin{column}[t]{0.5\textwidth}

            1.2. Gruppe:    \\
            c g a g         \\

            \medskip

            Präfix: $c g a g$

        \end{column}

        \begin{column}[t]{0.5\textwidth}
            
            <Bild: Neue Kante mit $c g a g $>

        \end{column}

    \end{columns}

    \bigskip

    <Bild: der gesamte Pfad vom Wurzel>

\end{frame}

%------------------------------------------------------------------
% Beispiel: Schritte für 2. Gruppe
%------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Schritte für 2. Gruppe}

    2. Gruppe:          \\
    g c g a c g a g     \\
    g a c g a g         \\
    g a g               \\
    g                   \\

\bigskip

<Bilder: kontinuierlicher Aufbau vom Pfad, paused?, mit Besichtigung von neuen Gruppen?>

\bigskip

<Ist es noch sowas für die Gruppe 3 nötig oder sofort das Ergebnis zeigen?>

\end{frame}

%------------------------------------------------------------------
% Haskell-code
%------------------------------------------------------------------

\subsection{Haskell-code}

%------------------------------------------------------------------
% Haskell-code: Typdefinitionen.
%------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Haskell-code: Typdefinitionen}

    Darstellung von Suffixbäumen:

    \medskip

    data STree alf = Leaf | Branch [(Label alf, STree alf)] deriving Eq

    \bigskip

    Darstellung von Beschriftungen:

    \medskip

    type Label alf = [alf]

    \bigskip

    Darstellung vom Kantenaufbau:

    \medskip

    type EdgeFunction alf = [[alf]] -> ([alf], [[alf]])

\end{frame}

%------------------------------------------------------------------
% Haskell-code: Schritt 1.
%------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Haskell-code: Schritt 1}

Liefert alle Suffixe von dem gegebenen Wort $aw$:

\bigskip

suffixes :: [alf] -> [[alf]]

\bigskip

suffixes []       = []              \\
suffixes aw@(\_:w) = aw:suffixes w  \\

\end{frame}

%------------------------------------------------------------------
% Haskell-code: Schritt 2.
%------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Haskell-code: Schritt 2}

    Liefert die Liste mit allen Wörter aus $ss$ 

    \bigskip

    select :: (Eq alf) => [[alf]] -> alf -> [[alf]] 

    \bigskip
    
    select ss a = [c:u | c:u <- ss, a == c]         

\end{frame}

\end{document}
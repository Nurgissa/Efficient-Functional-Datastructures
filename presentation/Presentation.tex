%////////////////////////////////////////////////////////////////////////////
% Präsentation "Suffix Trees und Suffix Arrays"
%////////////////////////////////////////////////////////////////////////////

% Autoren   : Simon Kaltenbacher, Evgeny Novoseltsev
% Semester  : WS 11/12
% Vorlesung : Effiziente funktionale Datenstrukturen
% Betreuer  : Prof. Martin Hofmann, PhD

%////////////////////////////////////////////////////////////////////////////

\documentclass{beamer}

%////////////////////////////////////////////////////////////////////////////
% Import
%////////////////////////////////////////////////////////////////////////////

\usepackage[ngerman]{babel}
\usepackage{textcomp}
% Umlaute in Ausgabedokument anzeigen
\usepackage[T1]{fontenc}
% Kodierung festlegen
%\usepackage{ucs}
\usepackage[utf8]{inputenc}
% Mathematische Notationen
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathtools, xfrac}
% Code von Programmiersprachen erkennen
% \usepackage{courier}
\usepackage{inconsolata}
\usepackage{listings, xcolor}
% Bäume zeichnen
\usepackage{tikz}
% Tabellen
\usepackage{booktabs}
\usepackage{tabularx}
% \usepackage{ctable}
% Literaturverzeichnis
\usepackage[numbers, square]{natbib}

%////////////////////////////////////////////////////////////////////////////
% Konfiguration
%////////////////////////////////////////////////////////////////////////////

%--colors--------------------------------------------------------------------

\definecolor{verylightgray}{RGB}{230, 230, 230}
\definecolor{rubineRed}{RGB}{243, 0, 125}
\definecolor{aquamarine}{RGB}{0, 193, 223}

%--listings-Konfiguration----------------------------------------------------

\definecolor{verylightgray}{RGB}{230, 230, 230}
\lstloadlanguages{Haskell}
\lstset {
    language = Haskell,
    tabsize = 4,
    showstringspaces = false,
    breaklines = true,
    basicstyle = \ttfamily\fontsize{8}{8}\selectfont,
    keywordstyle = \color{blue},
    commentstyle = \color{darkgray},
    frame = lines,
    extendedchars = true,
    framextopmargin = 5pt,
    xleftmargin = 5pt,
    framexleftmargin = 5pt,
    framexrightmargin = 5pt,
    framexbottommargin = 5pt,
    framerule = 0.5pt,
    rulecolor = \color{gray},
    backgroundcolor = \color{verylightgray}
}

%--Beamer Konfiguration------------------------------------------------------

\usetheme{Goettingen}
\beamersetuncovermixins{\opaqueness<1>{25}}{\opaqueness<2->{15}}

%--TikZ Konfiguration--------------------------------------------------------

\usetikzlibrary{trees, calc, shapes, scopes}

%--Styledefinitionen für Suffix Trees----------------------------------------

\tikzstyle{branch} = [
    shape = circle,
    minimum size = 1mm,
    inner sep = 0mm,
    outer sep = 0.5mm,
    fill
]
\tikzstyle{ghostbranch} = [
    shape = circle,
    draw,
    minimum size = 1mm,
    inner sep = 0mm,
    outer sep = 0.5mm
]
\tikzstyle{leaf} = [
    inner sep = 0mm,
    outer sep = 0mm
]
\tikzstyle{subtree} = [
    isosceles triangle,
    dotted,
    draw,
    shape border rotate = 90,
    isosceles triangle stretches = true,
    minimum height = 10mm,
    minimum width = 10mm,
    inner sep = 0,
    anchor = north,
    font = \tiny
]

%--Literaturverzeichnis------------------------------------------------------

% Literaturverzeichnis Stil
\bibliographystyle{alpha}

%--Benutzerdefinierte Makros-------------------------------------------------

% Umgebung Bemerkung
\newtheorem{remark}{Bemerkung}
\newtheorem{exampleg}{Beispiel}
\newtheorem{examplesg}{Beispiele}

\newcommand{\coloneqq}{\mathrel{\mathop:}=}

\newcommand{\abs}[1]{\left|#1\right|}

%--Übersetzung---------------------------------------------------------------

% Hack
\newcommand{\newblock}{}

%////////////////////////////////////////////////////////////////////////////
% Dokumenteigenschaften
%////////////////////////////////////////////////////////////////////////////

% Titel
\title{Suffix Trees und Suffix Arrays}

% Autoren
\author{Simon Kaltenbacher, Evgeny Novoseltsev}

% Erstellungsdatum
\date{\today}

%////////////////////////////////////////////////////////////////////////////
% Dokument
%////////////////////////////////////////////////////////////////////////////

\begin{document}

\selectlanguage{ngerman}

%--Folie: Titelfolie---------------------------------------------------------
\frame{\titlepage}
%--Folie---------------------------------------------------------------------

%--Folie: Inhaltsverzeichnis-------------------------------------------------
\frame{
    \frametitle{Inhaltsverzeichnis}
    \tableofcontents
}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\section{Einführung}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Einführung---------------------------------------------------------
\begin{frame}
\frametitle{Einführung}
\begin{itemize}
    \item Effiziente Lösung einer Vielzahl von Stringverarbeitungsproblemen
    \item Weit verbreitet in der Bioinformatik: Mustersuche in Genomen
    \item Lange Zeit theoretische Datenstruktur
    \item Konstruktion in $O(n)$ möglich \cite{Ukkonen1995}
    \item Suche eines Teilworts in $O(m)$, wobei $m$ Länge des Teilworts
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\section{Suffix Tree}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Sectionslide-------------------------------------------------------
\frame{\sectionpage}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsection{Terminologie}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Grundlagen---------------------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{itemize}
    \item $\Sigma$ endliches Alphabet
    \item $\epsilon$ leeres Wort
    \item $\Sigma^*$ Kleen'sche Hülle von $\Sigma$
    \item $\Sigma^+ \coloneqq \Sigma^* \setminus \{\epsilon\}$
    \item Im Folgenden bezeichnen
    \begin{itemize}
        \item $a$ - $g$ Buchstaben
        \item $t$ - $z$ Wörter
    \end{itemize}
    \item $uv$ Konkatenation der Wörter $u$ und $v$ mit $u, v \in \Sigma^*$
\end{itemize}
\begin{definition}[Präfix, Suffix, $t$-Wort]
    Sei $t = uvw$ mit $u, v, w \in \Sigma^*$. Dann ist $u$ ein Präfix und $w$ ein Suffix von $t$. $v$ wird als $t$-Wort bezeichnet.
\end{definition}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Grundlagen---------------------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{definition}[$\Sigma^+$-Baum]
    \begin{itemize}
    \item Die Kanten eines $\Sigma^+$-Baums sind mit Wörtern aus $\Sigma^+$ beschriftet.
    \item Für alle $a \in \Sigma$ und alle Knoten $k$ existiert höchstens ein Knoten $k'$, sodass $k \xrightarrow{aw} k'$.
    \end{itemize}
\end{definition}
\begin{exampleg}
Sei $\Sigma = \left\{a, \dots, z\right\}$
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 8mm, sibling distance = 25mm},
    level 2/.style = {level distance = 8mm, sibling distance = 15mm},
    level 3/.style = {level distance = 8mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$ad$}
        }
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[right, yshift = 0.5mm]{$gd$}
        }
        edge from parent
        node[above]{$ad$}
    }
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$a$}
        }
        edge from parent
        node[left]{$cg$}
    }
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$ga$}
        }
        child[child anchor = north] {
            node[subtree]{}
            edge from parent[dotted]
            node[right, yshift = 0.5mm, red]{$gc$}
        }
        edge from parent
        node[above]{$gac$}
    };
\end{tikzpicture}
\end{figure}
\end{exampleg}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Grundlagen---------------------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{definition}[Pfad]
Die Funktion $path(k)$ bezeichnet die Konkatenation der Kantenbeschriftungen von der Wurzel bis zum Knoten $k$.
\begin{remark}
$\overline{w}$ bezeichnet genau dann den Knoten $k$, wenn $path(k) = w$.
\end{remark}
\end{definition}
\begin{exampleg}
$w = vu$
\vspace{-8mm}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 8mm, sibling distance = 25mm},
    level 2/.style = {level distance = 8mm, sibling distance = 20mm},
    level 3/.style = {level distance = 8mm, sibling distance = 20mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch] {}
    child[child anchor = north] {
        node[subtree] {}
        edge from parent[dotted]
    }
    child {
        node[branch] {}
        child {
            node (n) [branch] {}
            child[child anchor = north] {
                node[subtree] {}
                edge from parent[dotted]
            }
            child[child anchor = north] {
                node[subtree] {}
                edge from parent[dotted]
            }
            edge from parent
            node[right] {$u$}
        }
        edge from parent
        node[left] {$v$}
    }
    child[child anchor = north] {
        node[subtree] {}
        edge from parent[dotted]
    };
    \node[left = 2mm] at (n) {$\overline{vu}$};
\end{tikzpicture}
\end{figure}
\end{exampleg}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Grundlagen---------------------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{itemize}
    \item Jedes $t$-Wort $w$ lässt sich darstellen als $t = vs, s = wu$
        \begin{gather*}
            t = a \dots b \underbrace{\overbrace{c \dots d}^{\text{Präfix }w} e \dots f}_{\text{Suffix }s}
        \end{gather*}
    \item Teilwortsuche im Suffix Tree: Präfixsuche auf Suffixen
    \item Ein Wort $w$ ist genau dann in einem $\Sigma^+$-Baum ent"-hal"-ten, wenn ein Knoten $\overline{wu}$ in diesem Baum existiert.
    \begin{figure}
    \begin{tikzpicture}[
        font = \small,
        level 1/.style = {level distance = 10mm, sibling distance = 25mm},
        level 2/.style = {level distance = 10mm, sibling distance = 15mm},
        level 3/.style = {level distance = 10mm, sibling distance = 10mm},
        edge from parent/.style = {->, draw}
        ]
        \node[branch] {}
        child[child anchor = north] {
            node[subtree] {}
            edge from parent[dotted]
        }
        child {
            node[branch] {}
            child[child anchor = north] {
                node[subtree] {}
                edge from parent[dotted]
            }
            child[child anchor = north] {
                node[subtree] {}
                edge from parent[dotted]
            }
            edge from parent
            node[left] {\textbf{w}u}
        }
        child[child anchor = north] {
            node[subtree] {}
            edge from parent[dotted]
        };
    \end{tikzpicture}
    \end{figure}
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Suffix Tree---------------------------------------------------------
\begin{frame}
\frametitle{Suffix Tree}
\begin{exampleg}
Suffixtree für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$cgag$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$gcgacgag$}
        }
        edge from parent
        node[above]{$a$}
    }
    child[level distance = 16mm] {
        node[branch]{}
        child {
            node[leaf] {}
            edge from parent
            node[left]{$cgag$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$g$}
        }
        edge from parent
        node[left]{$cga$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[leaf] {}
                edge from parent
                node[left]{$cgag$}
            }
            child {
                node[leaf] {}
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$cgacgag$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\end{exampleg}
\begin{definition}[Suffix Tree]
Ein Suffix Tree $S_t$ für ein gegebenes Wort $t$ ist ein $\Sigma^+$-Baum, sodass gilt:
\begin{gather*}
    w \in S_t \Longleftrightarrow w \text{ ist ein }t\text{-Wort}
\end{gather*}
\end{definition}
\vspace{-4mm}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsubsection{Suffix Tree Klassen}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Suffix Tree Klassen------------------------------------------------
\begin{frame}
\frametitle{Suffix Tree Klassen}
\begin{itemize}
    \item Drei Arten von Suffix Trees
    \begin{itemize}
        \item Atomic Suffix Tree (ast)
        \item Position Suffix Tree (pst)
        \item Compact Suffix Tree (cst)
    \end{itemize}
    \item ast, pst, cst stehen durch Kantenverschmelzung in Relation zueinander.
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Atomic Suffix Tree-------------------------------------------------
\begin{frame}
\frametitle{Atomic Suffix Tree}
\vspace{-2mm}
$ast(t)$ für die Zeichenkette $t = agcgacgag$.
\vspace{-2mm}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                    child {
                                        node[branch]{}
                                        child {
                                            edge from parent
                                            node[left]{$g$}
                                        }
                                        edge from parent
                                        node[left]{$a$}
                                    }
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$c$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            edge from parent
            node[right]{$g$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$c$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            edge from parent
            node[left]{$g$}
        }
        edge from parent
        node[left]{$c$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$a$}
                            }
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$c$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[right]{$c$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\vspace{-2mm}
Jedes Blatt repräsentiert ein Suffix von $t$.
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Kantenverschmelzung------------------------------------------------
\begin{frame}
\frametitle{Kantenverschmelzung}
\begin{definition}
Kantenverschmelzung ist eine Relation auf $\Sigma^+$-Bäumen, die durch ihre Kantenmengen repräsentiert werden.
\begin{gather*}
    \left(E \uplus \{\overline{s}\:\xrightarrow{u}\:\overline{w},\overline{w}\:\xrightarrow{u'}\:\overline{v}\}\right) \overset{\overline{w}}{\implies} \left(E \uplus \{\overline{s}\:\xrightarrow{uu'}\:\overline{v}\}\right)
\end{gather*}
wenn $\overline{w} \xrightarrow{u'} \overline{v}$ ist die einzige ausgehende Kante von $\overline{w}$.
\end{definition}
\begin{exampleg}
\begin{figure}
\vspace{-6mm}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 16mm},
    level 2/.style = {level distance = 7mm, sibling distance = 16mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [xshift = 0cm, yshift = 0cm]
        \node {}
        child {
            node[branch] (s1) {}
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            child {
                node[branch] (w1) {}
                child {
                    node[branch] (v1) {}
                    edge from parent
                    node[left]{$u'$}
                }
                edge from parent[solid]
                node[left]{$u$}
            }
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            edge from parent[dotted]
        };
    }
    \draw[red, dashed] (w1.center) circle (1mm);
    \node[subtree] at (v1.center) {};
    \node[yshift = 2mm, xshift = 3mm] at (s1.center) {$\overline{s}$};
    \node[right] at (w1.east) {$\overline{w}$};
    \node[right] at (v1.center) {$\overline{v}$};
    { [xshift = 2.5cm, yshift = {-1cm}]
        \node{$\overset{\overline{w}}{\implies}$};
    }
    { [xshift = 5cm, yshift = 0cm]
        \node{}
        child {
            node[branch] (s2) {}
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            child[level distance = 12mm] {
                node[branch] (v2) {}
                edge from parent[solid]
                node[left]{$uu'$}
            }
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            edge from parent[dotted]
        };
    }
    \node[subtree] at (v2.center) {};
    \node[yshift = 2mm, xshift = 3mm] at (s2.center) {$\overline{s}$};
    \node[right] at (v2.center) {$\overline{v}$};
\end{tikzpicture}
\end{figure}
\end{exampleg}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Atomic Suffix Tree -> Position Suffix Tree-------------------------
\begin{frame}
\frametitle{Atomic Suffix Tree $\rightarrow$ Position Suffix Tree}
$ast$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent[dotted]
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                    child {
                                        node[branch]{}
                                        child {
                                            edge from parent
                                            node[left]{$g$}
                                        }
                                        edge from parent
                                        node[left]{$a$}
                                    }
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$c$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            edge from parent[dotted]
            node[right]{$g$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent[dotted]
                    node[left]{$c$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            edge from parent
            node[left]{$g$}
        }
        edge from parent
        node[left]{$c$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent[dotted]
                node[left]{$c$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$a$}
                            }
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$c$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent[dotted]
            node[right]{$c$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Position Suffix Tree -> Compact Suffix Tree------------------------
\begin{frame}
\frametitle{Position Suffix Tree $\rightarrow$ Compact Suffix Tree}
$pst$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$cgag$}
        }
        child {
            edge from parent
            node[right]{$gcgacgag$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent[solid]
                    node[left]{$cgag$}
                }
                child {
                    edge from parent[solid]
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            edge from parent
            node[left]{$g$}
        }
        edge from parent[dotted]
        node[left]{$c$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            edge from parent
            node[right]{$cgacgag$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
$cst$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$cgag$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$gcgacgag$}
        }
        edge from parent
        node[above]{$a$}
    }
    child[level distance = 16mm] {
        node[branch]{}
        child {
            node[leaf] {}
            edge from parent
            node[left]{$cgag$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$g$}
        }
        edge from parent
        node[left]{$cga$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[leaf] {}
                edge from parent
                node[left]{$cgag$}
            }
            child {
                node[leaf] {}
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$cgacgag$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Suffix Tree Klassen------------------------------------------------
\begin{frame}
\frametitle{Suffix Tree Klassen}
\begin{definition}
Sei $S_t$ ein Suffix Tree für ein Wort $t$, repräsentiert durch seine Kantenmenge $E$
\begin{itemize}
    \item Atomic Suffix Tree, wenn $\abs{E}$ maximal ist.
    \item Position Suffix Tree, wenn die Länge aller inneren Kantenbeschriftungen $1$ beträgt.
    \item Compact Suffix Tree, wenn $\abs{E}$ minimal ist.
\end{itemize}
\end{definition}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Speicherplatzbedarf, cst-------------------------------------------
\begin{frame}
\frametitle{Speicherplatzbedarf}
\begin{lemma}
$cst$ besitzt einen Speicherplatzbedarf von $O(n)$.
\end{lemma}
\begin{proof}
\begin{itemize}
    \item cst besitzt höchstens $n$ Blätter
    \item jeder innere Knoten ist eine Verzweigung im $\boldsymbol{cst}$
    \item cst besitzt höchstens $n$ innere Knoten und somit höchstens $2n$ Kanten
    \item Jede Kante wird mit einem Paar $(i, j) \in \mathbb{N} \times \mathbb{N}$ beschriftet $\implies O(1)$ für jede Kante
    \item Insgesamt ergibt sich $O(n)$
\end{itemize}
\end{proof}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Speicherplatzbedarf, ast und pst-----------------------------------
\begin{frame}
\frametitle{Speicherplatzbedarf}
ast und pst benötigen mehr Speicherplatz:
\begin{itemize}
    \item ast hat $O(n^2)$ Knoten im Worst-Case (z.B. $a^nb^n$):
        \vspace{2mm}
        \begin{figure}
        \begin{tikzpicture}[
            font = \small,
            level 1/.style = {level distance = 7mm, sibling distance = 20mm},
            level 2/.style = {level distance = 7mm, sibling distance = 20mm},
            level 3/.style = {level distance = 7mm, sibling distance = 20mm},
            edge from parent/.style = {->, draw}
            ]
            \node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child[opacity = 0] {
                                node[branch]{}
                                edge from parent
                                node[right, yshift = 1mm]{}
                            }
                            child {
                                node[branch] (b5) {}
                                edge from parent
                                node[right, yshift = 1mm]{$b_1$}
                            }
                            edge from parent[solid]
                            node[left, yshift = 1mm]{$a_n$}
                        }
                        child {
                            node[branch] (b4) {}
                            edge from parent[solid]
                            node[right, yshift = 1mm]{$b_1$}
                        }
                        edge from parent[dotted]
                        node[left]{}
                    }
                    child {
                        node[branch] (b3) {}
                        edge from parent
                        node[right, yshift = 1mm]{$b_1$}
                    }
                    edge from parent
                    node[left, yshift = 1mm]{$a_2$}
                }
                child {
                    node[branch] (b2) {}
                    edge from parent
                    node[right, yshift = 1mm]{$b_1$}
                }
                edge from parent
                node[left, yshift = 1mm]{$a_1$}
            }
            child {
                node[branch] (b1) {}
                edge from parent
                node[right, yshift = 1mm]{$b_1$}
            };
            \node[subtree] at (b1.center) {$b^{n - 1}$};
            \node[subtree] at (b2.center) {$b^{n - 1}$};
            \node[subtree] at (b3.center) {$b^{n - 1}$};
            \node[subtree] at (b4.center) {$b^{n - 1}$};
            \node[subtree] at (b5.center) {$b^{n - 1}$};
            \node at (3.5, -1) {}; % Dummy Knoten
        \end{tikzpicture}
        \end{figure}
        \vspace{2mm}
    \item pst hat $O(n^2)$ Knoten im Worst-Case (z.B. $a^nb^na^nb^n$), aber in der Praxis $O(n)$
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsubsection{Generalized Suffix Tree}
%////////////////////////////////////////////////////////////////////////////

\begin{frame}
\frametitle{Generalized Suffix Tree}
\begin{itemize}
    \item $D = \{s_1, \dots, s_n\}$ eine Menge von Strings über $\Sigma$
    \item $T = \{t_1, \dots, t_n\}$ eine Menge von Terminalsymbolen mit $T \cap \Sigma = \emptyset$
    % \item Ein $GST_D$ ist ein $\Sigma^+$-Baum, sodass für alle $i \leq n$ gilt:
    %     \begin{gather*}
    %         w \in GST_D \Longleftrightarrow w \text{ ist ein } s_it_i\text{-Wort}
    %     \end{gather*}
\end{itemize}
\begin{exampleg}
GST für $D = \{agcg, acg\}$ und $T = \{\$, \#\}$. Suffix Tree für $agcg\$$ und $acg\#$
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 8mm, sibling distance = 30mm},
    level 2/.style = {level distance = 8mm, sibling distance = 15mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$gcg\$$}
        }
        child {
            edge from parent
            node[right]{$cg\#$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$\$$}
        }
        child {
            edge from parent
            node[right]{$\#$}
        }
        edge from parent
        node[left]{$cg$}
    }
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$cg\$$}
        }
        child {
            edge from parent
            node[left]{$\$$}
        }
        child {
            node[branch]{}
            edge from parent
            node[right]{$\#$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\end{exampleg}
\end{frame}

%////////////////////////////////////////////////////////////////////////////
\subsection{Anwendungsgebiete}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\subsubsection{Überblick}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Anwendungsgebiete--------------------------------------------------
\begin{frame}
\frametitle{Anwendungsgebiete}
Suffix Trees eignen sich insbesondere für Problemlösungen im Bereich der Stringverarbeitung.
\begin{figure}
\begin{tabular}{l}
    \toprule
    All-pairs suffix-prefix matching      \\
    Construction of DAWGs                 \\
    Exact set matching                    \\
    Exact string matching                 \\
    k-mismatch                            \\
    \textbf{Longest common substring}     \\
    Matching statistics                   \\
    Maximal repeated pairs                \\
    Maximal repeats                       \\
    Supermaximal repeats                  \\
    Ziv–Lempel decomposition              \\
    ...                                   \\
    \bottomrule
\end{tabular}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsubsection{Longest common substring}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Longest common substring-------------------------------------------
\begin{frame}
\frametitle{Longest common substring}
Bestimme die Ähnlichkeit zwischen Strings.

\begin{block}{Problem}
\begin{itemize}
    \item Gegeben zwei Strings $s_1, s_2 \in \Sigma^*$.
    \item Gesucht: Die Länge des längsten gemeinsamen Teilworts $lcs(s_1, s_2)$ von $s_1$ und $s_2$
\end{itemize}
\end{block}
\begin{exampleg}
$lcs(abab, aab) = 2$
\end{exampleg}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Longest common substring-------------------------------------------
\begin{frame}
\frametitle{Longest common substring}
\begin{theorem}
\begin{itemize}
    \item Gegebenen zwei Strings $s_1, s_2 \in \Sigma^*$
    \item $lcs(s_1, s_2)$ kann in $O(\abs{s_1} + \abs{s_2})$ gefunden werden.
\end{itemize}
\end{theorem}
\vspace{5mm}
$\rightarrow$ Lösung mithilfe eines GST
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Longest common substring-------------------------------------------
\begin{frame}
\frametitle{$LCS$-Algorithmus}
\begin{block}{Schritt 1}
\begin{itemize}
    \item Konstruiere $GST_D$ mit $D = \{s_1, s_2\}$ und $T = \{\$, \#\}$
    \item Aufwand $O(\abs{s_1} + \abs{s_2})$
\end{itemize}
\end{block}
\begin{exampleg}
Sei $D = \{gaga, agga\}$
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 8mm, sibling distance = 45mm},
    level 2/.style = {level distance = 8mm, sibling distance = 25mm},
    level 3/.style = {level distance = 8mm, sibling distance = 15mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$a\$$}
            }
            child {
                edge from parent
                node[right, xshift = 1mm]{$ga\#$}
            }
            edge from parent
            node[left]{$g$}
        }
        child {
            edge from parent
            node[right, xshift = 1mm]{$\$, \#$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$ga\$$}
            }
            child {
                edge from parent
                node[right]{$\$, \#$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            edge from parent
            node[right, xshift = 2mm]{$ga\#$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\end{exampleg}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Longest common substring-------------------------------------------
\begin{frame}
\frametitle{$LCS$-Algorithmus}
\begin{exampleg}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 8mm, sibling distance = 45mm},
    level 2/.style = {level distance = 8mm, sibling distance = 25mm},
    level 3/.style = {level distance = 8mm, sibling distance = 15mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch] (w1) {}
            child {
                edge from parent
                node[left]{$a\$$}
            }
            child {
                edge from parent
                node[right, xshift = 1mm]{$ga\#$}
            }
            edge from parent
            node[left]{$g$}
        }
        child {
            edge from parent
            node[right, xshift = 1mm]{$\$, \#$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch] (w2) {}
            child {
                edge from parent
                node[left]{$ga\$$}
            }
            child {
                edge from parent
                node[right]{$\$, \#$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            edge from parent
            node[right, xshift = 2mm]{$ga\#$}
        }
        edge from parent
        node[above]{$g$}
    };
    \node[yshift = 3mm, xshift = -7mm] at (w1.center) {$\overline{w}$} edge [dotted] (w1);
    \node[yshift = 3mm, xshift = -7mm] at (w2.center) {$\overline{w}$} edge [dotted] (w2);
\end{tikzpicture}
\end{figure}
\end{exampleg}
Ziel: Finde Knoten $\overline{w}$ mit maximaler Tiefe im $GST_D$ dessen Teilbäume ein Blatt von $s_1$ und $s_2$ besitzen.
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Longest common substring-------------------------------------------
\begin{frame}
\frametitle{$LCS$-Algorithmus}
% TODO Besseren Namen für Funktion f finden!
\begin{exampleg}
\vspace{-6mm}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 8mm, sibling distance = 45mm},
    level 2/.style = {level distance = 8mm, sibling distance = 25mm},
    level 3/.style = {level distance = 8mm, sibling distance = 15mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch] (b1) {}
    child {
        node[branch] (b2) {}
        child {
            node[branch] (b3) {}
            child {
                node[leaf] (l1) {}
                edge from parent
                node[left]{$a\$$}
            }
            child {
                node[leaf] (l2) {}
                edge from parent
                node[right, xshift = 1mm]{$ga\#$}
            }
            edge from parent
            node[left]{$g$}
        }
        child {
            node[leaf] (l3) {}
            edge from parent
            node[right, xshift = 1mm]{$\$, \#$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch] (b4) {}
        child {
            node[branch] (b5) {}
            child {
                node[leaf] (l4) {}
                edge from parent
                node[left]{$ga\$$}
            }
            child {
                node[leaf] (l5) {}
                edge from parent
                node[right]{$\$, \#$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[leaf] (l6) {}
            edge from parent
            node[right, xshift = 2mm]{$ga\#$}
        }
        edge from parent
        node[above]{$g$}
    };
    \node[yshift = 6mm] at (b1) {$(1, 1)$} edge [dotted] (b1);
    \node[yshift = 3mm, xshift = -8mm] at (b2) {$(1, 1)$} edge [dotted] (b2);
    \node[yshift = 3mm, xshift = -8mm] at (b3) {$(1, 1)$} edge [dotted] (b3);
    \node[yshift = 3mm, xshift = 8mm] at (b4) {$(1, 1)$} edge [dotted] (b4);
    \node[yshift = 3mm, xshift = -8mm] at (b5) {$(1, 1)$} edge [dotted] (b5);
    \node[yshift = -6mm] at (l1) {$(1, 0)$} edge [dotted] (l1);
    \node[yshift = -6mm] at (l2) {$0, 1)$} edge [dotted] (l2);
    \node[yshift = -14mm] at (l3) {$(1, 1)$} edge [dotted] (l3);
    \node[yshift = -6mm] at (l4) {$(1, 0)$} edge [dotted] (l4);
    \node[yshift = -6mm] at (l5) {$(1, 1)$} edge [dotted] (l5);
    \node[yshift = -14mm] at (l6) {$(0, 1)$} edge [dotted] (l6);
\end{tikzpicture}
\end{figure}
\end{exampleg}
\vspace{-5mm}
\begin{block}{Schritt 2}
\begin{itemize}
    \item Die Funktion $f$ ordnet jedem Knoten $\overline{w}$ im $GST_D$ einen zweidimensionalen Bitvektor $(b_1, b_2)$ zu, wobei
    \begin{gather*}
        b_i = \begin{cases}
            1 &\text{falls ein Teilbaum von } \overline{w} \text{ ein Blatt von } s_i \text{ besitzt} \\
            0 &\text{sonst}
        \end{cases}
    \end{gather*}
\end{itemize}
\end{block}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Longest common substring-------------------------------------------
\begin{frame}
\frametitle{$LCS$-Algorithmus}
\begin{exampleg}
\vspace{-6mm}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 8mm, sibling distance = 20mm},
    level 2/.style = {level distance = 8mm, sibling distance = 15mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch] (b) {}
    child[child anchor = north] {
        node[subtree] (st1) {$c_1$}
        edge from parent
    }
    child[child anchor = north] {
        node[subtree] (st2) {$c_2$}
        edge from parent
    }
    child[child anchor = north] {
        node[leaf] (st3) {}
        edge from parent[dotted]
    }
    child[child anchor = north] {
        node[subtree] (st4) {$c_l$}
        edge from parent
    };
    \node[yshift = 6mm, xshift = -6mm] at (b) {$(1, 1)$} edge [dotted] (b);
    \node[yshift = 3mm, xshift = 3mm] at (b) {$\overline{w}$};
    \node[yshift = -4mm] at (st1.south) {$(1, 0)$};
    \node[yshift = -4mm] at (st2.south) {$(0, 1)$};
    \node[yshift = -8mm] at (st3.south) {$\dots$};
    \node[yshift = -4mm] at (st4.south) {$(1, 0)$};
\end{tikzpicture}
\end{figure}
\end{exampleg}
\vspace{-5mm}
\begin{itemize}
    \item Die Oder-Verknüpfung der Bitvektoren der Kindknoten $c_1, \dots, c_l$ liefert den Bitvektor des Vaterknotens $\overline{w}$.
    \begin{gather*}
        f(\overline{w}) = \begin{cases}
            (b_1, b_2)                    &\text{falls } \overline{w} \text{ ein Blatt} \\
            f(c_1) \vee \dots \vee f(c_l) &\text{sonst}
        \end{cases}
    \end{gather*}
    \item Aufwand $O(\abs{s_1} + \abs{s_2})$
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Longest common substring-------------------------------------------
\begin{frame}
\frametitle{$LCS$-Algorithmus}
\begin{exampleg}
\vspace{-5mm}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 8mm, sibling distance = 45mm},
    level 2/.style = {level distance = 8mm, sibling distance = 25mm},
    level 3/.style = {level distance = 8mm, sibling distance = 15mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch] (w1) {}
            child {
                edge from parent
                node[left]{$a\$$}
            }
            child {
                edge from parent
                node[right, xshift = 1mm]{$ga\#$}
            }
            edge from parent
            node[left]{$g$}
        }
        child {
            edge from parent
            node[right, xshift = 1mm]{$\$, \#$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch] (w2) {}
            child {
                edge from parent
                node[left]{$ga\$$}
            }
            child {
                edge from parent
                node[right]{$\$, \#$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            edge from parent
            node[right, xshift = 2mm]{$ga\#$}
        }
        edge from parent
        node[above]{$g$}
    };
    \node[yshift = 3mm, xshift = -8mm] at (w1.center) {$(1, 1)$} edge [dotted] (w1);
    \node[yshift = 3mm, xshift = -8mm] at (w2.center) {$(1, 1)$} edge [dotted] (w2);
\end{tikzpicture}
\end{figure}
\end{exampleg}
\begin{block}{Schritt 3}
\begin{itemize}
    \item $lcs = max \{level(\overline{w}) \mid f(\overline{w}) = (1, 1) \text{ und } \overline{w} \in GST_D\}$
    \item Durchlaufe $GST_D$
    \item Falls $f(\overline{w}) = (1, 1)$ überprüfe, ob $level(\overline{w})$ größer als der bisher gefundene Wert.
    \item Gesamtaufwand $O(\abs{s_1} + \abs{s_2})$ wenn $f$ im Voraus berechnet wurde.
\end{itemize}
\end{block}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Longest common substring-------------------------------------------
\begin{frame}
\frametitle{Longest common substring}
\begin{remark}
    \begin{itemize}
        \item Verallgemeinerung von zwei auf $K$ Strings $s_1, \dots, s_k$ führt zu einem Aufwand von $O(nK)$, wobei $n = \sum_{i = 1}^K \abs{s_i}$
        \item Mit einem weiteren Vorverarbeitungsschritt des $GST$ lässt sich dieser Aufwand auf $O(n)$ reduzieren.
    \end{itemize}
\end{remark}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsection{Suffix Tree Konstruktion}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Subsectionslide-------------------------------------------------------
\frame{\subsectionpage}
%--Folie---------------------------------------------------------------------

%--Folie: Beispiel-----------------------------------------------------------
\begin{frame}
\frametitle{wotd-Algorithmus}
Write only top down Suffixbaumkonstruktion
\begin{itemize}
    \item WOTD eignet sich für lazy Suffixbäume
    \item Rekursive top-down Konstruktion, beginnend an der Wurzel mit allen Suffixen
    \item Jeder Unterbaum kann getrennt von den anderen konstruiert werden
    \item Knoten im Baum werden nur konstruiert, danach nicht mehr gelesen
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell: List comprehension----------------------------------------
\begin{frame}[fragile]
\frametitle{Haskell: List comprehension}
in Anlehnung an die mathematische Mengennotation
\begin{gather*}
    \{(i,j) \mid i \in \{1, 2\},\: j \in \{1, \dots, 4\}\}
\end{gather*}
ist äquivalent zu
\begin{gather*}
    [(i, j) \mid i \leftarrow [1,2],\: j \leftarrow [1..4]]
\end{gather*}
Syntax: $[e \mid q_1, \dots, q_n], n \geq 1$ , wobei die $q_i$ entweder
\begin{itemize}
    \item Generatoren, z. B. $i \leftarrow \left[1..4\right]$
    \item lokale Definitionen, z. B. $let\:i = x * x$
    \item Prädikate, z. B. $x > 2$
\end{itemize}
sind.
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell: List comprehension----------------------------------------
\begin{frame}[t, fragile]
\frametitle{Haskell: List comprehension}
\begin{examplesg}
\begin{enumerate}
    \item Mit Prädikat
    \begin{lstlisting}
    [2*x | x <- [0..10], x^2 > 5]
    -- ergibt
    [6, 8, 10, 12, 14, 16, 18, 20]
    \end{lstlisting}
    \item Mit lokaler Definition
    \begin{lstlisting}
    [(i, j) | i <- [1,2], let k = i * i, j <- [1..k]]
    -- ergibt
    [(1, 1), (2, 1), (2, 2), (2, 3), (2, 4)]
\end{lstlisting}
\end{enumerate}
\end{examplesg}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Typdefinitionen----------------------------------------------------
\begin{frame}[fragile]
\frametitle{Typdefinitionen}
\begin{lstlisting}
-- | Darstellung von Suffix Trees
data STree alf =
    Leaf | Branch [(Label alf, STree alf)]
    deriving Eq

-- | Darstellung von Beschriftungen
type Label alf = [alf]

-- | Darstellung vom Kantenaufbau
type EdgeFunction alf = [[alf]] -> ([alf], [[alf]])
\end{lstlisting}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 40mm},
    level 2/.style = {level distance = 10mm, sibling distance = 15mm},
    level 3/.style = {level distance = 10mm, sibling distance = 15mm},
    level 4/.style = {level distance = 10mm, sibling distance = 15mm},
    edge from parent/.style = {->, draw}
    ]
    { [yshift = 0cm]
        \node[branch]{}
        child[child anchor = north] {
            node[subtree] {$STree\:alf$}
            edge from parent
            node[above]{$Label\:alf$}
        }
        child[level distance = 16mm] {
            node[branch]{}
            child {
                edge from parent
                node[left] (l1) {$Label\:alf$}
            }
            child {
                edge from parent
                node[right](l2){$Label\:alf$}
            }
            edge from parent
            node[left]{$Label\:alf$}
        }
        child[child anchor = north] {
            node[subtree] {$STree\:alf$}
            edge from parent
            node[above]{$Label\:alf$}
        };
    }
    \node[yshift = -4mm] at (l1.south) {$Leaf$};
    \node[yshift = -4mm] at (l2.south) {$Leaf$};
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsubsection{Vorgehensweise}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Beispiel-----------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Beispiel für $agcgacgag$}
\begin{tabularx}{\textwidth}{l X}
Suffixe &  $agcgacgag$, $gcgacgag$, $cgacgag$, $gacgag$, $acgag$, $cgag$, $gag$, $ag$, $g$ \\
\end{tabularx}
\medskip
\begin{lstlisting}
suffixes :: [alf] -> [[alf]]
suffixes []       = []
suffixes aw@(_:w) = aw:suffixes w
\end{lstlisting}
\bigskip
\begin{remark}
\begin{description}[l]
    \item[Operator $(::)$] Typ-Spezifikations-Operator
    \item[Operator $(:)$] Cons-Operator: $h:[e_1, \dots, e_n] = [h, e_1, \dots, e_n]$
    \item[Operator $(@)$] Read-As-Operator: $aw@(\_:w)$ bedeutet, dass $(\_:w)$ an $aw$ gebunden wird.
\end{description}
\end{remark}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Beispiel-----------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Beispiel für $agcgacgag$}
\begin{table}
\begin{tabular}{l l l}
    \toprule
    Gruppe 1                 & Gruppe 2               & Gruppe 3                \\
    \midrule
    $\boldsymbol{a}gcgacgag$ & $\boldsymbol{cga}cgag$ & $\boldsymbol{g}cgacgag$ \\
    $\boldsymbol{a}cgag$     & $\boldsymbol{cga}g$    & $\boldsymbol{g}acgag$   \\
    $\boldsymbol{a}g$        &                        & $\boldsymbol{g}ag$      \\
                             &                        & $\boldsymbol{g}$        \\
    \midrule
    $a$                      & $cga$                  & $g$                     \\
    \bottomrule
\end{tabular}
\end{table}
\begin{lstlisting}
select :: (Eq alf) => [[alf]] -> alf -> [[alf]]
select ss a = [c:u | c:u <- ss, a == c]
\end{lstlisting}
\begin{lstlisting}
edge :: (Eq alf) => EdgeFunction alf
edge [s] = ([s], [[]])
edge awss@((a:_):ss)
    | all (\c:_ -> a == c) ss = (a:cp, rss)
    | otherwise               = ([], awss)
    where (cp, rss) = edge ([t | _:t <- awss, length t > 0])
\end{lstlisting}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Beispiel-----------------------------------------------------------
\begin{frame}
\frametitle{Beispiel für $agcgacgag$}
Erstes Level
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [yshift = 3.5cm]
        \node[branch]{}
        child {
            node[ghostbranch] (u) {}
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 8mm] {
            node[ghostbranch] (v) {}
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[ghostbranch] (w) {}
            edge from parent
            node[above]{$g$}
        };
        \node[align = left, anchor = north, yshift = {-1mm}] at (u.center) {$gcgacgag$ \\ $cgag$ \\ $g$};
        \node[align = left, anchor = north, yshift = {-1mm}] at (v.center) {$cgag$ \\ $g$};
        \node[align = left, anchor = north, yshift = {-1mm}] at (w.center) {$cgacgag$ \\ $acgag$ \\ $ag$};
    }
\end{tikzpicture}
\end{figure}
Die Restwörter werden abermals gruppiert.
\begin{table}
\begin{tabular}{l l}
    \toprule
    Gruppe 1                 & Gruppe 2               \\
    \midrule
    $\boldsymbol{g}cgacgag$  & $\boldsymbol{cgag}$    \\
    $\boldsymbol{g}$         &                        \\
    \midrule
    $gcgacgag$\footnote{Falls nur $g$ als das gemeinsame Präfix genommen wurde, dann hätte \\ man eine unnötige Kante im Baum} & $cgag$ \\
    \bottomrule
\end{tabular}
\end{table}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Beispiel-----------------------------------------------------------
\begin{frame}[t]
\frametitle{Beispiel für $agcgacgag$}
Zweites und drittes Level
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [yshift = 0cm]
        \node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 16mm] {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[branch]{}
            child {
                node[ghostbranch] (u) {}
                edge from parent
                node[left]{$a$}
            }
            child {
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
        \node[align = left, anchor = north, yshift = {-1mm}] at (u.center) {$cgag$ \\ $g$};
    }
\end{tikzpicture}
\end{figure}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \draw[dotted] (-4.5, 0.75) -- (5, 0.75);
    { [yshift = 0cm]
        \node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 16mm] {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent
                    node[left]{$cgag$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
    }
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: wotd-Algorithmus: Schritte-----------------------------------------
\begin{frame}[t]
\frametitle{Zusammenfassung der Schritte}
\begin{enumerate}
    \item Erzeuge alle Suffixe eines gegebenen Wortes.
    \item Gruppiere nach den Anfangsbuchstaben. Erzeuge einen Knoten.
    \item Für jede Gruppe:
    \begin{enumerate}
        \item Berechne das längste gemeinsame Präfix, erzeuge eine Kante mit der Beschriftung vom Präfix, entferne das Präfix von den Wörtern der Gruppe.
        \item Falls die Gruppe von Reswörter leer ist, erzeuge ein Blatt. Falls es in der Gruppe noch Wörter gibt, kehre zu Schritt 2 zurück.
    \end{enumerate}
\end{enumerate}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell-code: Baumaufbau-------------------------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Baumaufbau}
Die folgende Funktion baut den cst-Baum auf:
\begin{lstlisting}
lazy_cst ::(Eq alf) => (EdgeFunction alf) -> [alf] -> [alf] -> STree alf

lazy_cst edge alpha t = sTr (suffixes t)
    where
    sTr [[]] = Leaf
    sTr ss   = Branch[(cp,sTr rss) |
                   a <- alpha,
                   let gs = select ss a,
                   length gs > 0,
                   let (cp,rss) = edge gs
                   ]
\end{lstlisting}
\vspace{-3mm}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 10mm, sibling distance = 25mm},
    level 2/.style = {level distance = 10mm, sibling distance = 15mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch] (b) {}
    child[child anchor = north] {
        node[subtree] {$sTr\:rss$}
        edge from parent
        node[above]{$cp$}
    }
    child[child anchor = north] {
        node[subtree] {$sTr\:rss$}
        edge from parent
        node[left]{$cp$}
    }
    child[child anchor = north] {
        node[leaf] (st) {}
        edge from parent[dotted]
    }
    child[child anchor = north] {
        node[subtree] {$sTr\:rss$}
        edge from parent
        node[above]{$cp$}
    };
    \node[yshift = 4mm] at (b.center) {$Branch$};
    \node[yshift = -8mm] at (st.south) {$\dots$};
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsubsection{Laufzeitanalyse}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Laufzeitanalyse----------------------------------------------------
\begin{frame}[fragile]
\frametitle{Laufzeitanalyse $edge$}
\begin{lstlisting}
edge :: (Eq alf) => EdgeFunction alf
edge [s] = ([s], [[]])
edge awss@((a:_):ss)
    | all (\c:_ -> a == c) ss = (a:cp, rss)
    | otherwise               = ([], awss)
    where (cp, rss) = edge ([t | _:t <- awss, length t > 0])
\end{lstlisting}
\begin{block}{Abschätzung}
\vspace{-8mm}
\begin{align*}
    T(n,\abs{cp}) &= isEqual(n - 1) + newList(n) + T(n-1,\abs{cp}-1) \\
             &= \sum_{i = 1}^{\abs{cp}}{isEqual(n-1)} + \sum_{i = 1}^{\abs{cp}}{newList(n)} \\
             &= \abs{cp} (n - 1) + \abs{cp} n \in O(\abs{cp} \cdot n)
\end{align*}
wobei $|cp| \le n$.
\end{block}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Laufzeitanalyse----------------------------------------------------
\begin{frame}[fragile]
\frametitle{Laufzeitanalyse $lazy\_cst$}
\begin{lstlisting}
lazy_cst edge alpha t = sTr (suffixes t)
    where
    sTr [[]] = Leaf
    sTr ss   = Branch[(cp,sTr rss) |
                   a <- alpha,
                   let gs = select ss a,
                   length gs > 0,
                   let (cp,rss) = edge gs
                   ]
\end{lstlisting}
\begin{block}{Worst case: $t = a^n$}
\begin{itemize}
    \item Aufruf von $sTr$ mit $ss = [a^n,\:a^{n-1}, \dots ,\:a]$
    \item $gs = ss$
    \item Aufruf von $edge$: $cp = a^n$ und $rss = [[\:]]$
    \item Aufruf von $sTr$ mit $rss = [[\:]]$
\end{itemize}
Da $|cp| = n$, ist die Laufzeit von $edge$ und von dem gesamten Algorithmus $O(n^2)$.
\end{block}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsection{Teilwortsuche}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Haskell-Code: Teilwortsuche----------------------------------------
\begin{frame}[fragile]
\frametitle{Teilwortsuche}
Hilfsfunktion
\begin{lstlisting}
commonPrefix :: (Eq alph) => Word alph -> Word alph -> (Word alph, Word alph, Word alph)

commonPrefix w1 w2 = g w1 w2 []
    where g (x:xs) (y:ys) cp | (x == y) = g xs ys (x:cp)
          g w1 w2 cp  = (w1, w2, reverse cp)
\end{lstlisting}
\begin{examplesg}
\begin{lstlisting}
-- Erstes Teilwort von Zweitem
commonPrefix "abc" "abcde" = ([ ], de, abc)

-- Zweites Teilwort von Erstem
commonPrefix "abcde" "abc" = (de, [ ], abc)

-- Disjunkt
commonPrefix "abc" "de" = (abc, de, [ ])

-- Gemeinsames Praefix "ab"
commonPrefix "abcd" "abde" = (cd, de, ab)
\end{lstlisting}
\end{examplesg}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell-Code: Suche------------------------------------------------
\begin{frame}[fragile]
\frametitle{Teilwortsuche}
\begin{lstlisting}
search :: (Eq alph) => Word alph -> STree alph -> Bool

search ss Leaf        = False
search ss (Branch es) =  g ss es
    where
    g ss [] = False
    g ss (((l, st):es)) =
        case commonPrefix ss l of
         ([], _, _)   -> True          -- ss ist leer
         (_, _, [])   -> g ss es       -- falsche Kante
         (ss', [], _) -> search ss' st -- richtige Kante
         _            -> False         -- cp != []|l|ss

let alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
    word = "agcgacgag"
in  search "cgac" (lazy_cst edge alphabet word)
\end{lstlisting}
\vspace{-3mm}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [yshift = 0cm]
        \node[branch]{}
        child {
            node[branch] (a) {}
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 16mm] {
            node[branch]{}
            child {
                edge from parent
                node[left]{$\boldsymbol{c}gag$}
            }
            child[child anchor = north] {
                edge from parent[dotted]
            }
            edge from parent
            node[left]{$\boldsymbol{cga}$}
        }
        child[child anchor = north] {
            edge from parent[dotted]
        };
    }
    \node[subtree] at (a.center) {};
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\section{Suffix Array}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Sectionslide-------------------------------------------------------
\frame{\sectionpage}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsection{Motivation}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Motiviation--------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivation}
Suffix Trees haben einige Nachteile
\begin{itemize}
    \item Speicherplatzverbrauch: 20 Bytes für jedes Zeichen im Worst-Case $\rightarrow$ macht Suffix Trees für viele Real-Welt-Anwendungen unbrauchbar.
    \item Lässt sich schlecht extern implementieren
\end{itemize}
\vspace{5mm}
Diese Nachteile werden von Suffix Arrays größtenteils behoben
\begin{itemize}
    \item Speicherplatzverbrauch: 5 Bytes für jedes Zeichen
    \item Vielversprechende Algorithmen für die effiziente Konstruktion von Suffix Arrays im externen Speicher \cite{Dementiev2008}
    \item Suche eines Teilworts in $O(m + \log n)$ mit zusätzlicher Datenstruktur
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Suffix Array-------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Suffix Array}
\begin{exampleg}
Suffixarray für $yabbadabbado$ ist $SA = (1, 6, 4, 9, 3, 8, 2, 7, 5, 10, 11, 0)$, wobei
\begin{table}
\begin{tabular}{l l|l l}
    \toprule
    $S_1$       & $a b b a d a b b a d o$ & $S_2$    & $b b a d a b b a d o$     \\
    $S_6$       & $a b b a d o$           & $S_7$    & $b b a d o$               \\
    $S_4$       & $a d a b b a d o$       & $S_5$    & $d a b b a d o$           \\
    $S_9$       & $a d o$                 & $S_{10}$ & $d o$                     \\
    $S_3$       & $b a d a b b a d o$     & $S_{11}$ & $o$                       \\
    $S_8$       & $b a d o$               & $S_0$    & $y a b b a d a b b a d o$ \\
    \bottomrule
\end{tabular}
\end{table}
\end{exampleg}
\begin{definition}
Suffixarray $SA$ von $t$ ist eine Permutation von $[0,n]$ mit $S_{SA[0]} \prec S_{SA[1]} \prec \dots \prec S_{SA[n]}$, wobei $\prec$ die lexikographische Ordnung auf Zeichenketten bezeichnet.
\end{definition}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsection{DC3-Algorithmus}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Subsectionslide----------------------------------------------------
\frame{\subsectionpage}
%--Folie---------------------------------------------------------------------

%--Folie: Grundlegende Idee--------------------------------------------------
\begin{frame}
\frametitle{DC3: Grundlegende Idee}
Divide and Conquer Ansatz
\vspace{5mm}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 20mm, sibling distance = 45mm},
    level 2/.style = {level distance = 20mm, sibling distance = 45mm},
    level 3/.style = {level distance = 20mm, sibling distance = 45mm},
    edge from parent/.style = {->, draw}
    ]
    \node (n1) {
        \begin{tabular}{c}
            Schritt 1: Divide \color{rubineRed}y\color{aquamarine}ab\color{rubineRed}b\color{aquamarine}ad\color{rubineRed}a\color{aquamarine}bb\color{rubineRed}a\color{aquamarine}do \\
            \midrule
            \color{black}Schritt 4: Merge \\
        \end{tabular}}
    child {
        node {Schritt 3: Sort}
        edge from parent[color = rubineRed]
        node[left, xshift = -2mm]{\color{rubineRed}i mod 3 = 0}
        node[right, xshift = 2mm]{\color{rubineRed}$\sfrac{1}{3}$}
    }
    child {
        node {Schritt 2: Sort recursive}
        child {
            edge from parent[color = rubineRed, dotted]
        }
        child {
            edge from parent[color = aquamarine, dotted]
        }
        edge from parent[color = aquamarine]
        node[right, xshift = 2mm]{\color{aquamarine}i mod 3 = 1 o. 2}
        node[left, xshift = -2mm]{\color{aquamarine}$\sfrac{2}{3}$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Schritt 1: Divide--------------------------------------------------
\begin{frame}
\frametitle{Schritt 1: Divide}
\begin{figure}
\tabcolsep1mm
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 20mm, sibling distance = 55mm},
    level 2/.style = {level distance = 20mm, sibling distance = 55mm},
    edge from parent/.style = {->, draw}
    ]
    \node {
        \begin{tabular}{c c c c c c c c c c c c}
            \color{rubineRed}0 & \color{aquamarine}1 & \color{aquamarine}2 & \color{rubineRed}3 & \color{aquamarine}4 & \color{aquamarine}5 & \color{rubineRed}6 & \color{aquamarine}7 & \color{aquamarine}8 & \color{rubineRed}9 & \color{aquamarine}10 & \color{aquamarine}11 \\
            \color{rubineRed}y & \color{aquamarine}a & \color{aquamarine}b & \color{rubineRed}b & \color{aquamarine}a & \color{aquamarine}d & \color{rubineRed}a & \color{aquamarine}b & \color{aquamarine}b & \color{rubineRed}a & \color{aquamarine}d & \color{aquamarine}o \\
        \end{tabular}
    }
    child[child anchor = north] {
        node[align = left, anchor = north] {
            \color{rubineRed}y\color{gray}abbadabbado \\
            \color{rubineRed}b\color{gray}adabbado    \\
            \color{rubineRed}a\color{gray}bbado       \\
            \color{rubineRed}a\color{gray}do          \\
        }
        edge from parent[color = rubineRed]
        node[left, xshift = -2mm]{\color{rubineRed}i mod 3 = 0}
    }
    child[child anchor = north] {
        node[align = left, anchor = north] {
            \begin{tabular}{l}
                \color{aquamarine}a\color{gray}bbadabbado \\
                \color{aquamarine}a\color{gray}dabbado    \\
                \color{aquamarine}b\color{gray}bado       \\
                \color{aquamarine}d\color{gray}o          \\
                \midrule
                \color{aquamarine}b\color{gray}badabbado  \\
                \color{aquamarine}d\color{gray}abbado     \\
                \color{aquamarine}b\color{gray}ado        \\
                \color{aquamarine}o                       \\
            \end{tabular}
        }
        edge from parent[color = aquamarine]
        node[right, xshift = 2mm]{\color{aquamarine}i mod 3 = 1 o. 2}
    };
\end{tikzpicture}
\end{figure}
\tabcolsep6pt
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Übersicht----------------------------------------------------------
\begin{frame}
\frametitle{Übersicht}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 20mm, sibling distance = 45mm},
    level 2/.style = {level distance = 20mm, sibling distance = 45mm},
    level 3/.style = {level distance = 20mm, sibling distance = 45mm},
    edge from parent/.style = {->, draw}
    ]
    \node (n1) {
        \begin{tabular}{c}
            \color{gray}Schritt 1: Divide \color{rubineRed}y\color{aquamarine}ab\color{rubineRed}b\color{aquamarine}ad\color{rubineRed}a\color{aquamarine}bb\color{rubineRed}a\color{aquamarine}do \\
            \midrule
            \color{gray}Schritt 4: Merge \\
        \end{tabular}}
    child {
        node {\color{gray}Schritt 3: Sort}
        edge from parent[color = rubineRed]
        node[left, xshift = -2mm]{\color{rubineRed}i mod 3 = 0}
        node[right, xshift = 2mm]{\color{rubineRed}$\sfrac{1}{3}$}
    }
    child {
        node {Schritt 2: Sort recursive}
        child {
            edge from parent[color = rubineRed, dotted]
        }
        child {
            edge from parent[color = aquamarine, dotted]
        }
        edge from parent[color = aquamarine]
        node[right, xshift = 2mm]{\color{aquamarine}i mod 3 = 1 o. 2}
        node[left, xshift = -2mm]{\color{aquamarine}$\sfrac{2}{3}$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Schritt 1: Sort recursived-----------------------------------------
\begin{frame}
\frametitle{Schritt 2: Sort recursive}
Samples erzeugen und konkatenieren
\begin{figure}
\begin{tikzpicture}
    { [xshift = -2cm]
        \node (n1) {\color{gray}y\color{aquamarine}a\color{gray}bb\color{aquamarine}a\color{gray}da\color{aquamarine}b\color{gray}ba\color{aquamarine}d\color{gray}o};
        \node[below = 2cm] (n2) at (n1) {\color{black}[\color{aquamarine}a\color{gray}bb\color{black}][\color{aquamarine}a\color{gray}da\color{black}\color{black}][\color{aquamarine}b\color{gray}ba\color{black}][\color{aquamarine}d\color{gray}o0\color{black}]};
        \path[->, color = aquamarine] (n1) edge (n2);
    }
    { [xshift = 2cm]
        \node (n3) {\color{gray}ya\color{blue}b\color{gray}ba\color{blue}d\color{gray}ab\color{blue}b\color{gray}ad\color{blue}o};
        \node[below = 2cm] (n4) at (n3) {\color{black}[\color{blue}b\color{gray}ba\color{black}][\color{blue}d\color{gray}ab\color{black}][\color{blue}b\color{gray}ad\color{black}][\color{blue}o\color{gray}00\color{black}]};
        \path[->, color = blue] (n3) edge (n4);
    }
    { [yshift = -4cm]
        \node (n5) {\color{black}[\color{aquamarine}a\color{gray}bb\color{black}][\color{aquamarine}a\color{gray}da\color{black}\color{black}][\color{aquamarine}b\color{gray}ba\color{black}][\color{aquamarine}d\color{gray}o0\color{black}][\color{blue}b\color{gray}ba\color{black}][\color{blue}d\color{gray}ab\color{black}][\color{blue}b\color{gray}ad\color{black}][\color{blue}o\color{gray}00\color{black}]};
        \path[->, color = aquamarine] (n2) edge (n5);
        \path[->, color = blue] (n4) edge (n5);
    }
\end{tikzpicture}
\end{figure}
Jedes Sample repräsentiert ein Suffix
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Schritt 2: Sort recursiv-d-----------------------------------------
\begin{frame}
\frametitle{Schritt 2: Sort recursive}
\begin{itemize}
    \item Samples mit Radixsort lexikographisch sortieren
        \begin{figure}
        \begin{tikzpicture}
            [
                matrix of nodes/.style = {
                execute at begin cell = \node\bgroup,
                execute at end cell = \egroup;%
            }]
            \matrix[ampersand replacement = \&, column sep = -2mm, matrix of nodes]
            {
                1 \&
                2 \&
                3 \&
                4 \&
                5 \&
                6 \&
                7 \\
                \color{black}[\color{aquamarine}a\color{gray}bb\color{black}] \&
                \color{black}[\color{aquamarine}a\color{gray}da\color{black}\color{black}] \&
                \color{black}[\color{blue}b\color{gray}ad\color{black}] \&
                \color{black}[\color{aquamarine}b\color{gray}ba\color{black}] \&
                \color{black}[\color{blue}d\color{gray}ab\color{black}] \&
                \color{black}[\color{aquamarine}d\color{gray}o0\color{black}] \&
                \color{black}[\color{blue}o\color{gray}00\color{black}] \\
            };
        \end{tikzpicture}
        \end{figure}
    \item Samples durch Rang ersetzen
        \begin{figure}
        \begin{tikzpicture}
            \node (n1) {\color{black}[\color{aquamarine}a\color{gray}bb\color{black}][\color{aquamarine}a\color{gray}da\color{black}\color{black}][\color{aquamarine}b\color{gray}ba\color{black}][\color{aquamarine}d\color{gray}o0\color{black}][\color{blue}b\color{gray}ba\color{black}][\color{blue}d\color{gray}ab\color{black}][\color{blue}b\color{gray}ad\color{black}][\color{blue}o\color{gray}00\color{black}]};
            \node[below = 1cm] (n2) at (n1) {[1][2][4][6][4][5][3][7]};
            \path[->] (n1) edge (n2);
        \end{tikzpicture}
        \end{figure}
        Informationen aus Sortierschritt werden in die Samples kodiert
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Schritt 2: Sort recursive------------------------------------------
\begin{frame}
\frametitle{Schritt 2: Sort recursive}
\begin{gather*}
    R = 12464537
\end{gather*}
Ist der Rang der Samples eindeutig?
\begin{itemize}
    \item Wenn, ja: Rang der Samples entspricht Suffixarray für $i \text{ mod } 3 = 1 \text{ oder } 2$ Suffixes.
    \item Sonst: Sortiere $R$ mit DC3 rekursiv
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Schritt 2: Sort recursive------------------------------------------
\begin{frame}
\frametitle{Schritt 2: Sort recursive}
\begin{itemize}
    \item Rekursiver Aufruf von DC3 mit $R = 12464537$
        \begin{figure}
        \begin{tikzpicture}
            [
                matrix of nodes/.style = {
                execute at begin cell = \node\bgroup,
                execute at end cell = \egroup;%
                }
            ]
            \matrix[ampersand replacement = \&, column sep = -2mm, matrix of nodes] (m) {
                \color{black}[ \& \color{aquamarine}a\color{gray}bb\color{black} \& ] \&
                \color{black}[ \& \color{aquamarine}a\color{gray}da\color{black}\color{black} \& ] \&
                \color{black}[ \& \color{aquamarine}b\color{gray}ba\color{black} \& ] \&
                \color{black}[ \& \color{aquamarine}d\color{gray}o0\color{black} \& ] \&
                \color{black}[ \& \color{blue}b\color{gray}ba\color{black} \& ] \&
                \color{black}[ \& \color{blue}d\color{gray}ab\color{black} \& ] \&
                \color{black}[ \& \color{blue}b\color{gray}ad\color{black} \& ] \&
                \color{black}[ \& \color{blue}o\color{gray}00\color{black} \& ] \& \\
                \color{black}[ \& 1 \& ] \&
                \color{black}[ \& 2 \& ] \&
                \color{black}[ \& 4 \& ] \&
                \color{black}[ \& 6 \& ] \&
                \color{black}[ \& 4 \& ] \&
                \color{black}[ \& 5 \& ] \&
                \color{black}[ \& 3 \& ] \&
                \color{black}[ \& 7 \& ] \& \\
                               \&   \&   \&
                               \&   \&   \&
                \color{black}[ \& 4 \&   \&
                               \& 6 \&   \&
                               \& 4 \& ] \&
                               \&   \&   \&
                               \&   \&   \&
                               \&   \&   \& \\
                               \&   \&   \&
                               \&   \&   \&
                               \&   \&   \&
                               \&   \&   \&
                \color{black}[ \& 4 \&   \&
                               \& 5 \&   \&
                               \& 3 \& ] \&
                               \&   \&   \& \\
            };
            \node[left = 2cm, above = 2cm] (n1) at (m) {\color{gray}y\color{aquamarine}a\color{gray}bb\color{aquamarine}a\color{gray}da\color{aquamarine}b\color{gray}ba\color{aquamarine}d\color{gray}o};
            \node[right = 2cm, above = 2cm] (n2) at (m) {\color{gray}ya\color{blue}b\color{gray}ba\color{blue}d\color{gray}ab\color{blue}b\color{gray}ad\color{blue}o};
            \fill[aquamarine!30] (-1.8, 2.1) -- (-0.75, 2.1) -- (0, 1.25) -- (-1.8, 1.25) -- cycle;
            \fill[blue!30] (1.25, 2.1) -- (3.15, 2.1) -- (3.9, 1.25) -- (0.15, 1.25) -- cycle;
        \end{tikzpicture}
        \end{figure}
    \item Ergebnis des rekursiven Aufrufs
        \begin{table}
        \begin{tabular}{l|c c c c c c c c}
            \toprule
            $R$  & 1 & 2 & 4 & 6 & 4 & 5 & 3 & 7 \\
            \midrule
            Rang & 1 & 2 & 7 & 5 & 3 & 6 & 4 & 8 \\
            \bottomrule
        \end{tabular}
        \end{table}
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Übersicht----------------------------------------------------------
\begin{frame}
\frametitle{Übersicht}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 20mm, sibling distance = 45mm},
    level 2/.style = {level distance = 20mm, sibling distance = 45mm},
    level 3/.style = {level distance = 20mm, sibling distance = 45mm},
    edge from parent/.style = {->, draw}
    ]
    \node (n1) {
        \begin{tabular}{c}
            \color{gray}Schritt 1: Divide \color{rubineRed}y\color{aquamarine}ab\color{rubineRed}b\color{aquamarine}ad\color{rubineRed}a\color{aquamarine}bb\color{rubineRed}a\color{aquamarine}do \\
            \midrule
            \color{gray}Schritt 4: Merge \\
        \end{tabular}}
    child {
        node {Schritt 3: Sort}
        edge from parent[color = rubineRed]
        node[left, xshift = -2mm]{\color{rubineRed}i mod 3 = 0}
        node[right, xshift = 2mm]{\color{rubineRed}$\sfrac{1}{3}$}
    }
    child {
        node {\color{gray}Schritt 2: Sort recursive}
        child {
            edge from parent[color = rubineRed, dotted]
        }
        child {
            edge from parent[color = aquamarine, dotted]
        }
        edge from parent[color = aquamarine]
        node[right, xshift = 2mm]{\color{aquamarine}i mod 3 = 1 o. 2}
        node[left, xshift = -2mm]{\color{aquamarine}$\sfrac{2}{3}$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Schritt 3: Sort----------------------------------------------------
\begin{frame}
\frametitle{Schritt 3: Sort}
\begin{itemize}
    \item  Sortiere $i \text{ mod } 3 = 0$ Suffixes nach ihrem ersten Buchstaben mit Radixsort
        \vspace{4mm}
        \begin{figure}
        \begin{tikzpicture}
            \node (n1) {
                \color{magenta}y\color{gray}ab\color{magenta}b\color{gray}ad\color{magenta}a\color{gray}bb\color{magenta}a\color{gray}do
            };
            \node[align = left, below = 2cm] (n2) at (n1) {
                \color{rubineRed}a\color{gray}bbado       \\
                \color{rubineRed}a\color{gray}do          \\
                \color{rubineRed}b\color{gray}adabbado    \\
                \color{rubineRed}y\color{gray}abbadabbado \\
            };
            \path[->, color = magenta] (n1) edge (n2);
        \end{tikzpicture}
        \end{figure}
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Übersicht----------------------------------------------------------
\begin{frame}
\frametitle{Übersicht}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 20mm, sibling distance = 45mm},
    level 2/.style = {level distance = 20mm, sibling distance = 45mm},
    level 3/.style = {level distance = 20mm, sibling distance = 45mm},
    edge from parent/.style = {->, draw}
    ]
    \node (n1) {
        \begin{tabular}{c}
            \color{gray}Schritt 1: Divide \color{rubineRed}y\color{aquamarine}ab\color{rubineRed}b\color{aquamarine}ad\color{rubineRed}a\color{aquamarine}bb\color{rubineRed}a\color{aquamarine}do \\
            \midrule
            Schritt 4: Merge \\
        \end{tabular}}
    child {
        node {\color{gray}Schritt 3: Sort}
        edge from parent[color = rubineRed]
        node[left, xshift = -2mm]{\color{rubineRed}i mod 3 = 0}
        node[right, xshift = 2mm]{\color{rubineRed}$\sfrac{1}{3}$}
    }
    child {
        node {\color{gray}Schritt 2: Sort recursive}
        child {
            edge from parent[color = rubineRed, dotted]
        }
        child {
            edge from parent[color = aquamarine, dotted]
        }
        edge from parent[color = aquamarine]
        node[right, xshift = 2mm]{\color{aquamarine}i mod 3 = 1 o. 2}
        node[left, xshift = -2mm]{\color{aquamarine}$\sfrac{2}{3}$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Schritt 4: Merge---------------------------------------------------
\begin{frame}
\frametitle{Schritt 4: Merge}
\begin{table}
\begin{tabular}{l|c c c c c c c c c c c c}
    \toprule
    i    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
    \midrule
    Wort & y & a & b & b & a & d & a & b & b & a & d  & o  \\
    \midrule
    Rang & ? & 1 & 4 & ? & 2 & 6 & ? & 5 & 3 & ? & 7  & 8 \\
    \bottomrule
\end{tabular}
\end{table}
\vspace{2mm}
\begin{itemize}
    \item $[yab]\:?\:[abb]: a < y \rightarrow [abb] < [yab]$
    \item $[abb]_1\:?\:[abb]_6$ (Index 1 und Index 6): \\ Benutzung von dem existierten Rang: $[abb]_1 \rightarrow (a,4)$ und $[abb]_6 \rightarrow (a,5)$, $(a,4) < (a,5) \rightarrow [abb]_1 < [abb]_6$
    \item $[bad]_3\:?\:[bad]_8$: \\ $[bad]_3 \rightarrow (b,a,6)$ und $[bad]_8 \rightarrow (b,a,7)$, $(b,a,6) < (b,a,7) \rightarrow [bad]_3 < [bad]_8$
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Ergebnis-----------------------------------------------------------
\begin{frame}
\frametitle{Ergebnis}
\begin{figure}
\begin{tikzpicture}
    \node (n1) {
        \begin{tabular}{l|c c c c c c c c c c c c}
            \toprule
            Wort & y  & a & b & b & a & d & a & b & b & a & d  & o  \\
            \midrule
            Rang & 12 & 1 & 7 & 5 & 3 & 9 & 2 & 8 & 6 & 4 & 10 & 11 \\
            \bottomrule
        \end{tabular}
    };
    \node[below = 2cm] (n2) {
        \begin{tabular}{l l|l l}
            \toprule
            $S_1$       & $a b b a d a b b a d o$ & $S_2$    & $b b a d a b b a d o$     \\
            $S_6$       & $a b b a d o$           & $S_7$    & $b b a d o$               \\
            $S_4$       & $a d a b b a d o$       & $S_5$    & $d a b b a d o$           \\
            $S_9$       & $a d o$                 & $S_{10}$ & $d o$                     \\
            $S_3$       & $b a d a b b a d o$     & $S_{11}$ & $o$                       \\
            $S_8$       & $b a d o$               & $S_0$    & $y a b b a d a b b a d o$ \\
            \bottomrule
        \end{tabular}
    };
    \path[->] (n1) edge (n2);
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Eigenschaften------------------------------------------------------
\begin{frame}
\frametitle{Eigenschaften von DC3}
\begin{itemize}
    \item Laufzeitkomplexität im Worst case $O(n)$
    \item schnellster Algorithmus mit Worst case $O(n)$
    \item Schnellere Algorithmen, wie z.B. qsufsort \cite{Larsson2007} in der Praxis mit schlechterem Worst case $O(n \log n)$
\end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Literaturverzeichnis-----------------------------------------------
\begin{frame}[allowframebreaks]
\frametitle{Literaturverzeichnis}
\nocite{*}
\bibliography{refs}
\end{frame}
%--Folie---------------------------------------------------------------------

\end{document}
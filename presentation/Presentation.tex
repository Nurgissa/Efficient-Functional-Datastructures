%------------------------------------------------------------------
% Präsentation "Suffix Trees und Suffix Arrays"
%------------------------------------------------------------------

% Autoren   : Simon Kaltenbacher, Evgeny Novoseltsev
% Semester  : WS 11/12
% Vorlesung : Effiziente funktionale Datenstrukturen
% Betreuer  : Prof. Martin Hofmann, PhD

% Latex Beamer Tutorial kann unter folgendem Link gefunden werden: http://www.math.umbc.edu/~rouben/beamer/quickstart.html

% Eine nützliche Sammlung von Beispielen für die Latex Beamer-Klasse kann unter folgendem Link gefunden werden: http://www.informatik.uni-freiburg.de/~frank/latex-kurs/latex-kurs-3/Latex-Kurs-3.html

\documentclass{beamer}
\usepackage[ngerman]{babel}
\usepackage{textcomp}
% Umlaute in Ausgabedokument anzeigen
\usepackage[T1]{fontenc}
% Kodierung festlegen$
%\usepackage{ucs}
\usepackage[utf8]{inputenc}
% Mathematische Notationen
\usepackage{amsmath, amsfonts, amssymb, mathtools}
% Bäume zeichnen
\usepackage{tikz}
% Code von Programmiersprachen erkennen
\usepackage{listings}

% listings-Konfiguration
\lstloadlanguages{Haskell}
\lstset{basicstyle=\scriptsize}

% Beamer Konfiguration
\usetheme{Goettingen}
%\usecolortheme{sidebartab}
%\useoutertheme{default}
\beamersetuncovermixins{\opaqueness<1>{25}}{\opaqueness<2->{15}}

\usetikzlibrary{trees, calc, shapes, scopes}

% Styledefinitionen für Suffix Trees
\tikzstyle{branch} = [
    shape = circle,
    minimum size = 1mm,
    inner sep = 0mm,
    outer sep = 0.5mm,
    fill
]
\tikzstyle{subtree} = [
    isosceles triangle,
    dotted,
    draw,
    shape border rotate = 90,
    isosceles triangle stretches = true,
    minimum height = 10mm,
    minimum width = 10mm,
    inner sep = 0,
    anchor = north,
    font = \tiny
]

%--Benutzerdefinierte Makros---------------------------------------

% Umgebung Bemerkung
\newtheorem{remark}[theorem]{Bemerkung}

\newcommand{\coloneqq}{\mathrel{\mathop:}=}
%------------------------------------------------------------------

% Titel
\title{Suffix Trees und Suffix Arrays}  

% Autoren
\author{Simon Kaltenbacher, Evgeny Novoseltsev}

% Erstellungsdatum
\date{\today}

% Dokument
\begin{document}

%--Folie: Titelfolie-----------------------------------------------
\frame{\titlepage}
%--Folie-----------------------------------------------------------

%--Folie: Inhaltsverzeichnis---------------------------------------
\frame{\frametitle{Inhaltsverzeichnis}\tableofcontents}
%--Folie-----------------------------------------------------------

%------------------------------------------------------------------
\section{Einführung}
%------------------------------------------------------------------

%------------------------------------------------------------------
\section{Terminologie}
%------------------------------------------------------------------

%------------------------------------------------------------------
\subsection{Grundlagen}
%------------------------------------------------------------------

%--Folie: Grundlagen-----------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{itemize}
    \item $\Sigma$ endliches Alphabet
    \item $\epsilon$ leeres Wort
    \item $\Sigma^*$ Kleen'sche Hülle von $\Sigma$
    \item $\Sigma^+ \coloneqq \Sigma^* \setminus \{\epsilon\}$
    \item Im Folgenden bezeichnen
    \begin{itemize}
        \item $a$ - $g$ Buchstaben
        \item $t$ - $z$ Wörter
    \end{itemize}
    \item $uv$ Konkatenation der Wörter $u$ und $v$ mit $u, v \in \Sigma^+$
\end{itemize}
\begin{definition}[Präfix, Suffix, $t$-Wort]
    Sei $t = uvw$ mit $u, v, w \in \Sigma^*$. Dann ist $u$ ein Präfix und $w$ ein Suffix von $t$. $v$ wird als $t$-Wort bezeichnet.
\end{definition}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Grundlagen-----------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{definition}[$\Sigma^+$-Baum]
    $\Sigma^+$-Baum ist ein Baum mit Kantenbeschriftungen aus $\Sigma^+$. Für alle $a \in \Sigma$ existiert höchstens eine $a$-Kante mit $k \xrightarrow{aw} k'$. Die Menge aller $\Sigma^+$-Bäume bezeichnen wir mit $T\:(\Sigma^+)$.
\end{definition}
\begin{example}
Sei $\Sigma = \left\{a, \dots, z\right\}$
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 25mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{g}
        }
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[right, yshift = 0.5mm]{h}
        }
        edge from parent
        node[above]{ab}
    }
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{i}
        }
        edge from parent
        node[left]{c}
    }
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{j}
        }
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[right, yshift = 0.5mm]{kl}
        }
        edge from parent
        node[above]{def}
    };
\end{tikzpicture}
\end{figure}
\end{example}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Grundlagen-----------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{definition}[Pfad]
    Die Funktion $path(k)$ bezeichnet die Konkatenation der Kantenbeschriftungen von der Wurzel eines $\Sigma^+$-Baumes bis zum Knoten $k$.
    \begin{remark}
    $\overline{w}$ bezeichnet genau dann einen Knoten $k$, wenn $path(k) = w$.
    \end{remark}
\end{definition}
\begin{definition}[Verschachteltes Suffix]
    Ein Suffix von $t$ heißt verschachtelt, wenn es mehrmals in $t$ vorkommt, d.h. $t = uvwv$.
\end{definition}
\begin{example}
    $ag$ ist ein verschachteltes Suffix von $\underline{ag}cgacg\underline{ag}$.
\end{example}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Grundlagen-----------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{definition}[Suffix Tree]
    Ein Suffix Tree $S_t$ für ein gegebenes Wort $t$ ist ein $\Sigma^+$-Baum, sodass gilt:
    $$w \in S_t  \Longleftrightarrow w \text{ ist ein }t\text{-Wort}$$
\end{definition}
\begin{remark}
    Jedes $t$-Wort $w$ lässt sich darstellen als: $t = vs, s = wu$
    $$t = a \dots b \underbrace{\overbrace{c \dots d}^{\text{Präfix }w} e \dots f}_{\text{Suffix }s}$$
    Ein Wort $w$ ist genau dann in einem $\Sigma^+$-Baum enthalten, wenn ein Knoten $\overline{wu}$ in diesem Baum existiert.
\end{remark}
\end{frame}
%--Folie-----------------------------------------------------------

%------------------------------------------------------------------
\subsection{Suffix Tree Klassen}
%------------------------------------------------------------------

%--Folie: Atomic Suffix Tree---------------------------------------
\begin{frame}
\frametitle{Atomic Suffix Tree}
$ast$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                    child {
                                        node[branch]{}
                                        child {
                                            edge from parent
                                            node[left]{$g$}
                                        }
                                        edge from parent
                                        node[left]{$a$}
                                    }
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$c$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            edge from parent
            node[right]{$g$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$c$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            edge from parent
            node[left]{$g$}
        }
        edge from parent
        node[left]{$c$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$a$}
                            }
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$c$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[right]{$c$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Kantenverschmelzung--------------------------------------
\begin{frame}
\frametitle{Kantenverschmelzung}
\begin{definition}
    Kantenverschmelzung ist eine Relation auf $\Sigma^+$-Bäumen, die durch ihre Kantenmengen repräsentiert werden.
    $$\left(E \uplus \{\overline{s}\:\xrightarrow{u}\:\overline{w},\overline{w}\:\xrightarrow{u'}\:\overline{v}\}\right) \overset{\overline{w}}{\implies} \left(E \uplus \{\overline{s}\:\xrightarrow{uu'}\:\overline{v}\}\right)$$
    wenn $\overline{w} \xrightarrow{u'} \overline{v}$ ist die einzige ausgehende Kante von $\overline{w}$.
\end{definition}
\begin{example}
\begin{figure}
\vspace{-6mm}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 16mm},
    level 2/.style = {level distance = 7mm, sibling distance = 16mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    { [xshift = 0cm, yshift = 0cm]
        \node {}
        child {
            node[branch] (s1) {}
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            child {
                node[branch] (w1) {}
                child {
                    node[branch] (v1) {}
                    edge from parent
                    node[left]{$u'$}
                }
                edge from parent[solid]
                node[left]{$u$}
            }
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            edge from parent[dotted]
        };
    }
    \draw[red, dashed] (w1.center) circle (1mm);
    \node[subtree] at (v1.center) {};
    \node[yshift = 2mm, xshift = 3mm] at (s1.center) {$\overline{s}$};
    \node[right] at (w1.east) {$\overline{w}$};
    \node[right] at (v1.center) {$\overline{v}$};
    { [xshift = 2.5cm, yshift = {-1cm}]
        \node{$\overset{\overline{w}}{\implies}$};
    }
    { [xshift = 5cm, yshift = 0cm]
        \node{}
        child {
            node[branch] (s2) {}
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            child[level distance = 12mm] {
                node[branch] (v2) {}
                edge from parent[solid]
                node[left]{$uu'$}
            }
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            edge from parent[dotted]
        };
    }
    \node[subtree] at (v2.center) {};
    \node[yshift = 2mm, xshift = 3mm] at (s2.center) {$\overline{s}$};
    \node[right] at (v2.center) {$\overline{v}$};
\end{tikzpicture}
\end{figure}
\end{example}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Atomic Suffix Tree -> Position Suffix Tree---------------
\begin{frame}
\frametitle{Atomic Suffix Tree $\rightarrow$ Position Suffix Tree}
$ast$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent[dotted]
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                    child {
                                        node[branch]{}
                                        child {
                                            edge from parent
                                            node[left]{$g$}
                                        }
                                        edge from parent
                                        node[left]{$a$}
                                    }
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$c$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            edge from parent[dotted]
            node[right]{$g$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent[dotted]
                    node[left]{$c$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            edge from parent
            node[left]{$g$}
        }
        edge from parent
        node[left]{$c$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent[dotted]
                node[left]{$c$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$a$}
                            }
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$c$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent[dotted]
            node[right]{$c$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Position Suffix Tree -> Compact Suffix Tree--------------
\begin{frame}
\frametitle{Position Suffix Tree $\rightarrow$ Compact Suffix Tree}
$pst$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{cgag}
        }
        child {
            edge from parent
            node[right]{gcgacgag}
        }
        edge from parent
        node[above]{a}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent[solid]
                    node[left]{cgag}
                }
                child {
                    edge from parent[solid]
                    node[right]{g}
                }
                edge from parent
                node[left]{a}
            }
            edge from parent
            node[left]{g}
        }
        edge from parent[dotted]
        node[left]{c}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{cgag}
            }
            child {
                edge from parent
                node[right]{g}
            }
            edge from parent
            node[left]{a}
        }
        child {
            edge from parent
            node[right]{cgacgag}
        }
        edge from parent
        node[above]{g}
    };
\end{tikzpicture}
\end{figure}

$cst$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{cgag}
        }
        child {
            edge from parent
            node[right]{gcgacgag}
        }
        edge from parent
        node[above]{a}
    }
    child[level distance = 16mm] {
        node[branch]{}
        child {
            edge from parent
            node[left]{cgag}
        }
        child {
            edge from parent
            node[right]{g}
        }
        edge from parent
        node[left]{cga}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{cgag}
            }
            child {
                edge from parent
                node[right]{g}
            }
            edge from parent
            node[left]{a}
        }
        child {
            edge from parent
            node[right]{cgacgag}
        }
        edge from parent
        node[above]{g}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie-----------------------------------------------------------

%------------------------------------------------------------------
% wotd-Algorithmus: Beispiel
%------------------------------------------------------------------

\subsection{Beispiel}

%--Folie: Beispiel-------------------------------------------------
\begin{frame}[t]
\frametitle{Beispiel für $agcgacgag$}
$Suffixe = \{agcgacgag, gcgacgag, cgacgag, gacgag, acgag, cgag, \newline gag, ag, g\}$
\medskip
\begin{columns}
    \begin{column}[t]{0.3\textwidth}
        1. Gruppe:  
        $agcgacgag$  \\
        $acgag$      \\  
        $ag$         \\ 
    \end{column}
    \begin{column}[t]{0.3\textwidth}
        2. Gruppe:        \\
        $cgacgag$   \\
        $cgag$         \\
    \end{column}
    \begin{column}[t]{0.3\textwidth}
        3. Gruppe:      \\
        $gcgacgag$ \\
        $gacgag$     \\
        $gag$           \\
        $g$               \\
    \end{column}
\end{columns}
\medskip
\begin{columns}
    \begin{column}[t]{0.3\textwidth}
        Präfix: $a$
    \end{column}
    \begin{column}[t]{0.3\textwidth}
        Präfix: $cga$
    \end{column}
    \begin{column}[t]{0.3\textwidth}
        Präfix: $g$
    \end{column}
\end{columns}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        edge from parent
        node[above]{a}
    }
    child[level distance = 8mm] {
        edge from parent
        node[left]{cga}
    }
    child {
        edge from parent
        node[above]{g}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Beispiel-------------------------------------------------
\begin{frame}
\frametitle{Beispiel für $agcgacgag$}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{cgag}
        }
        child {
            edge from parent
            node[right]{g}
        }
        edge from parent
        node[above]{a}
    }
    child[level distance = 16mm] {
        node[branch]{}
        child {
            edge from parent
            node[left]{cgag}
        }
        child {
            edge from parent
            node[right]{g}
        }
        edge from parent
        node[left]{cga}
    }
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{a}
        }
        child {
            edge from parent
            node[right]{cgacgag}
        }
        edge from parent
        node[above]{g}
    };
\end{tikzpicture}
\end{figure}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{cgag}
        }
        child {
            node[branch] (v) {}
            child[level distance = 10mm]{
                edge from parent
                node[left]{cgacgag}
            }
            edge from parent
            node[right]{g}
        }
        edge from parent
        node[above]{a}
    }
    child[level distance = 16mm] {
        node[branch]{}
        child {
            edge from parent
            node[left]{cgag}
        }
        child {
            edge from parent
            node[right]{g}
        }
        edge from parent
        node[left]{cga}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{cgag}
            }
            child {
                edge from parent
                node[right]{g}
            }
            edge from parent
            node[left]{a}
        }
        child {
            edge from parent
            node[right]{cgacgag}
        }
        edge from parent
        node[above]{g}
    };
    \draw[red, dashed] (v.center) circle (1mm);
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie-----------------------------------------------------------

%------------------------------------------------------------------
% wotd-Algorithmus: Schritte
%------------------------------------------------------------------

\section{wotd-Algorithmus}

\subsection{Vorgehensweise}

%--Folie: wotd-Algorithmus: Schritte-------------------------------
\begin{frame}[t]
\frametitle{wotd-Algorithmus für cst}
    Write-only top-down construction for suffix trees.
    \medskip
    Schritte:
    \begin{enumerate}
    \item Finde alle Suffixe eines gegebenen Wortes.
    \item Gruppiere nach den Anfangsbuchstaben. Erzeuge einen Knoten.
    \item Für jede Gruppe:
    \begin{enumerate}
    \item Finde das längste gemeinsame Präfix, erzeuge eine Kante mit der Beschriftung vom Präfix, entferne das Präfix von den Wörtern der Gruppe.
    \item Falls die Gruppe leer ist, erzeuge ein Blatt. Falls es in der Gruppe noch Wörter gibt, kehre zu Schritt 2 zurück.
    \end{enumerate}
    \end{enumerate}
\end{frame}
%--Folie-----------------------------------------------------------

%------------------------------------------------------------------
% Haskell-code
%------------------------------------------------------------------

\subsection{Haskell-code}

%--Folie: Haskell-code: Typdefinitionen----------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Typdefinitionen}
Darstellung von Suffixbäumen:
\begin{lstlisting}{haskell}
data STree alf = Leaf | 
                 Branch [(Label alf,STree alf)] deriving Eq
\end{lstlisting}
\bigskip
Darstellung von Beschriftungen:
\begin{lstlisting}{haskell}
type Label alf = [alf]
\end{lstlisting}
\bigskip
Darstellung vom Kantenaufbau:
\begin{lstlisting}{haskell}
type EdgeFunction alf = [[alf]] -> ([alf],[[alf]])
\end{lstlisting}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Haskell-code: Liste von Suffixen-------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Liste von Suffixen}
    Folgende Funktion liefert alle Suffixe von dem gegebenen Wort $aw$:
    \begin{lstlisting}{haskell}
    suffixes :: [alf] -> [[alf]]

    suffixes []       = []              
    suffixes aw@(_:w) = aw:suffixes w 
    \end{lstlisting}
    \bigskip
    \begin{remark}
    \begin{lstlisting}{haskell}
    aw@(_:w)
    \end{lstlisting} bedeutet, dass $aw$ mit $(\_:w)$ gematcht wird.         
    \end{remark}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Haskell-code: Auswahl------------------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Auswahl einer Gruppe}
    Folgende Funktion liefert die Liste mit allen Wörter aus $ss$, die mit $a$ anfangen:
\begin{lstlisting}{haskell}
select :: (Eq alf) => [[alf]] -> alf -> [[alf]]

select ss a = [c:u | c:u <- ss, a == c]
\end{lstlisting}
\bigskip
\begin{remark}
\begin{lstlisting}{haskell}
c:u <- ss
\end{lstlisting} bedeutet $c:u \in ss$
\end{remark}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Haskell-code: Kantenerzeugung----------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Kantenerzeugung}
Folgende Funktion erzeugt die Kante mit der längster-Präfix- Beschriftung für eine gegebene Liste von Wörter:
\begin{lstlisting}{haskell}
edge_cst :: (Eq alf) => EdgeFunction alf

edge_cst [s] = ([s], [[]])
edge_cst awss@((a:_):ss) 
    | all (\c:_ -> a == c) ss =  (a:cp, rss)
    | otherwise               =  ([], awss)
      where (cp, rss)         =  edge_cst ([t | _:t <- awss])
\end{lstlisting}
\bigskip
\begin{remark}
\begin{lstlisting}{haskell}
all :: (a -> Bool) -> [a] -> Bool

all p [] = true
all p x:xs = p x && all p xs
\end{lstlisting}     
\end{remark}
\end{frame}
%--Folie-----------------------------------------------------------

%--Folie: Haskell-code: Baumaufbau---------------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Baumaufbau}
Die folgende Funktion baut den cst-Baum auf:
\begin{lstlisting}{haskell}
lazy_cst :: (Eq alf) => 
(EdgeFunction alf) -> [alf] -> [alf] -> STree alf

lazy_cst edge_cst alpha t = sTr (suffixes t)
where sTr [[]] = Leaf
      sTr ss   = Branch[(cp, sTr rss)|a <- alpha,
                                      let gs = select ss a,
                                      let (cp,rss) = edge_cst gs]
\end{lstlisting}
\end{frame}
%--Folie-----------------------------------------------------------

\begin{frame}
    
\end{frame}

\end{document}



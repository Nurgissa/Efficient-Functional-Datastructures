%////////////////////////////////////////////////////////////////////////////
% Präsentation "Suffix Trees und Suffix Arrays"
%////////////////////////////////////////////////////////////////////////////

% Autoren   : Simon Kaltenbacher, Evgeny Novoseltsev
% Semester  : WS 11/12
% Vorlesung : Effiziente funktionale Datenstrukturen
% Betreuer  : Prof. Martin Hofmann, PhD

%////////////////////////////////////////////////////////////////////////////

\documentclass{beamer}

%////////////////////////////////////////////////////////////////////////////
% Import
%////////////////////////////////////////////////////////////////////////////

\usepackage[ngerman]{babel}
\usepackage{textcomp}
% Umlaute in Ausgabedokument anzeigen
\usepackage[T1]{fontenc}
% Kodierung festlegen
%\usepackage{ucs}
\usepackage[utf8]{inputenc}
% Mathematische Notationen
\usepackage{amsmath, amsfonts, amssymb, mathtools}
% Bäume zeichnen
\usepackage{tikz}
% Code von Programmiersprachen erkennen
\usepackage{listings, courier, xcolor}
% Tabellen
\usepackage{booktabs}
\usepackage{tabularx}
% \usepackage{ctable}

%////////////////////////////////////////////////////////////////////////////
% Konfiguration
%////////////////////////////////////////////////////////////////////////////

%--listings-Konfiguration----------------------------------------------------

\definecolor{verylightgray}{RGB}{230, 230, 230}
\lstloadlanguages{Haskell}
\lstset {
    language = Haskell,
    tabsize = 4,
    showstringspaces = false,
    breaklines = true,S
    basicstyle= \ttfamily\fontsize{9}{10}\selectfont,
    keywordstyle = \color{blue},
    commentstyle = \color{darkgray},
    frame = lines,
    extendedchars = true,
    framextopmargin = 5pt,
    xleftmargin = 5pt,
    framexleftmargin = 5pt,
    framexrightmargin = 5pt,
    framexbottommargin = 5pt,
    framerule = 0.5pt,
    rulecolor = \color{gray},
    backgroundcolor = \color{verylightgray}
}

%--Beamer Konfiguration------------------------------------------------------

\usetheme{Goettingen}
\beamersetuncovermixins{\opaqueness<1>{25}}{\opaqueness<2->{15}}

%--TikZ Konfiguration--------------------------------------------------------

\usetikzlibrary{trees, calc, shapes, scopes}

%--Styledefinitionen für Suffix Trees----------------------------------------

\tikzstyle{branch} = [
    shape = circle,
    minimum size = 1mm,
    inner sep = 0mm,
    outer sep = 0.5mm,
    fill
]
\tikzstyle{ghostbranch} = [
    shape = circle,
    draw,
    minimum size = 1mm,
    inner sep = 0mm,
    outer sep = 0.5mm,
]
\tikzstyle{subtree} = [
    isosceles triangle,
    dotted,
    draw,
    shape border rotate = 90,
    isosceles triangle stretches = true,
    minimum height = 10mm,
    minimum width = 10mm,
    inner sep = 0,
    anchor = north,
    font = \tiny
]

%--Benutzerdefinierte Makros-------------------------------------------------

% Umgebung Bemerkung
\newtheorem{remark}[theorem]{Bemerkung}

\newcommand{\coloneqq}{\mathrel{\mathop:}=}

\newcommand{\abs}[1]{\left|#1\right|}

%////////////////////////////////////////////////////////////////////////////
% Dokumenteigenschaften
%////////////////////////////////////////////////////////////////////////////

% Titel
\title{Suffix Trees und Suffix Arrays}

% Autoren
\author{Simon Kaltenbacher, Evgeny Novoseltsev}

% Erstellungsdatum
\date{\today}

%////////////////////////////////////////////////////////////////////////////
% Dokument
%////////////////////////////////////////////////////////////////////////////

\begin{document}

%--Folie: Titelfolie---------------------------------------------------------
\frame{\titlepage}
%--Folie---------------------------------------------------------------------

%--Folie: Inhaltsverzeichnis---------------------------------------------------
\frame{\frametitle{Inhaltsverzeichnis}\tableofcontents}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\section{Einführung}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Einführung---------------------------------------------------------
\begin{frame}
\frametitle{Einführung}
% TODO Einführung ausarbeiten!
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\section{Suffix Tree}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\subsection{Terminologie}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Grundlagen---------------------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{itemize}
    \item $\Sigma$ endliches Alphabet
    \item $\epsilon$ leeres Wort
    \item $\Sigma^*$ Kleen'sche Hülle von $\Sigma$
    \item $\Sigma^+ \coloneqq \Sigma^* \setminus \{\epsilon\}$
    \item Im Folgenden bezeichnen
    \begin{itemize}
        \item $a$ - $g$ Buchstaben
        \item $t$ - $z$ Wörter
    \end{itemize}
    \item $uv$ Konkatenation der Wörter $u$ und $v$ mit $u, v \in \Sigma^*$
\end{itemize}
\begin{definition}[Präfix, Suffix, $t$-Wort]
    Sei $t = uvw$ mit $u, v, w \in \Sigma^*$. Dann ist $u$ ein Präfix und $w$ ein Suffix von $t$. $v$ wird als $t$-Wort bezeichnet.
\end{definition}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Grundlagen---------------------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{definition}[$\Sigma^+$-Baum]
    \begin{itemize}
    \item Die Kanten eines $\Sigma^+$-Baums sind mit Wörtern aus $\Sigma^+$ beschriftet.
    \item Für alle $a \in \Sigma$ und alle Knoten $k$ existiert höchstens ein Knoten $k'$, sodass $k \xrightarrow{aw} k'$.
    \end{itemize}
\end{definition}
\begin{example}
Sei $\Sigma = \left\{a, \dots, z\right\}$
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 8mm, sibling distance = 25mm},
    level 2/.style = {level distance = 8mm, sibling distance = 15mm},
    level 3/.style = {level distance = 8mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$ad$}
        }
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[right, yshift = 0.5mm]{$gd$}
        }
        edge from parent
        node[above]{$ad$}
    }
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$a$}
        }
        edge from parent
        node[left]{$cg$}
    }
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$ga$}
        }
        child[child anchor = north] {
            node[subtree]{}
            edge from parent[dotted]
            node[right, yshift = 0.5mm, red]{$gc$}
        }
        edge from parent
        node[above]{$gac$}
    };
\end{tikzpicture}
\end{figure}
\end{example}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Grundlagen---------------------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{definition}[Pfad]
    Die Funktion $path(k)$ bezeichnet die Konkatenation der Kantenbeschriftungen von der Wurzel eines $\Sigma^+$-Baumes bis zum Knoten $k$.
    \begin{remark}
    $\overline{w}$ bezeichnet genau dann den Knoten $k$, wenn $path(k) = w$.
    \end{remark}
\end{definition}
\begin{definition}[Verschachteltes Suffix]
    Ein Suffix von $t$ heißt verschachtelt, wenn es mehrmals in $t$ vorkommt, d.h. $t = uvwv$.
\end{definition}
\begin{example}
    $\boldsymbol{ag}$ ist ein verschachteltes Suffix von $\boldsymbol{ag}cgacg\boldsymbol{ag}$.
\end{example}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Grundlagen---------------------------------------------------------
\begin{frame}
\frametitle{Grundlagen}
\begin{definition}[Suffix Tree]
    Ein Suffix Tree $S_t$ für ein gegebenes Wort $t$ ist ein $\Sigma^+$-Baum, sodass gilt:
    $$w \in S_t  \Longleftrightarrow w \text{ ist ein }t\text{-Wort}$$
\end{definition}
\begin{remark}
    Jedes $t$-Wort $w$ lässt sich darstellen als: $t = vs, s = wu$
    $$t = a \dots b \underbrace{\overbrace{c \dots d}^{\text{Präfix }w} e \dots f}_{\text{Suffix }s}$$
    Ein Wort $w$ ist genau dann in einem $\Sigma^+$-Baum enthalten, wenn ein Knoten $\overline{wu}$ in diesem Baum existiert.
\end{remark}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsection{Suffix Tree Klassen}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Suffix Tree Klassen------------------------------------------------
\begin{frame}
    \frametitle{Suffix Tree Klassen}
    \begin{itemize}
        \item Drei Arten von Suffix Trees
        \begin{itemize}
            \item Atomic Suffix Tree (ast)
            \item Position Suffix Tree (pst)
            \item Compact Suffix Tree (cst)
        \end{itemize}
        \item ast, pst, cst stehen durch Kantenverschmelzung in Relation zueinander.
    \end{itemize}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Atomic Suffix Tree-------------------------------------------------
\begin{frame}
\frametitle{Atomic Suffix Tree}
\vspace{-2mm}
$ast(t)$ für die Zeichenkette $t = agcgacgag$.
\vspace{-2mm}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                    child {
                                        node[branch]{}
                                        child {
                                            edge from parent
                                            node[left]{$g$}
                                        }
                                        edge from parent
                                        node[left]{$a$}
                                    }
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$c$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            edge from parent
            node[right]{$g$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$c$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            edge from parent
            node[left]{$g$}
        }
        edge from parent
        node[left]{$c$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$a$}
                            }
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$c$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[right]{$c$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\vspace{-2mm}
Jedes Blatt repräsentiert ein Suffix von $t$.
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Kantenverschmelzung------------------------------------------------
\begin{frame}
\frametitle{Kantenverschmelzung}
\begin{definition}
    Kantenverschmelzung ist eine Relation auf $\Sigma^+$-Bäumen, die durch ihre Kantenmengen repräsentiert werden.
    $$\left(E \uplus \{\overline{s}\:\xrightarrow{u}\:\overline{w},\overline{w}\:\xrightarrow{u'}\:\overline{v}\}\right) \overset{\overline{w}}{\implies} \left(E \uplus \{\overline{s}\:\xrightarrow{uu'}\:\overline{v}\}\right)$$
    wenn $\overline{w} \xrightarrow{u'} \overline{v}$ ist die einzige ausgehende Kante von $\overline{w}$.
\end{definition}
\begin{example}
\begin{figure}
\vspace{-6mm}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 16mm},
    level 2/.style = {level distance = 7mm, sibling distance = 16mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [xshift = 0cm, yshift = 0cm]
        \node {}
        child {
            node[branch] (s1) {}
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            child {
                node[branch] (w1) {}
                child {
                    node[branch] (v1) {}
                    edge from parent
                    node[left]{$u'$}
                }
                edge from parent[solid]
                node[left]{$u$}
            }
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            edge from parent[dotted]
        };
    }
    \draw[red, dashed] (w1.center) circle (1mm);
    \node[subtree] at (v1.center) {};
    \node[yshift = 2mm, xshift = 3mm] at (s1.center) {$\overline{s}$};
    \node[right] at (w1.east) {$\overline{w}$};
    \node[right] at (v1.center) {$\overline{v}$};
    { [xshift = 2.5cm, yshift = {-1cm}]
        \node{$\overset{\overline{w}}{\implies}$};
    }
    { [xshift = 5cm, yshift = 0cm]
        \node{}
        child {
            node[branch] (s2) {}
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            child[level distance = 12mm] {
                node[branch] (v2) {}
                edge from parent[solid]
                node[left]{$uu'$}
            }
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            edge from parent[dotted]
        };
    }
    \node[subtree] at (v2.center) {};
    \node[yshift = 2mm, xshift = 3mm] at (s2.center) {$\overline{s}$};
    \node[right] at (v2.center) {$\overline{v}$};
\end{tikzpicture}
\end{figure}
\end{example}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Atomic Suffix Tree -> Position Suffix Tree-------------------------
\begin{frame}
\frametitle{Atomic Suffix Tree $\rightarrow$ Position Suffix Tree}
$ast$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent[dotted]
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                    child {
                                        node[branch]{}
                                        child {
                                            edge from parent
                                            node[left]{$g$}
                                        }
                                        edge from parent
                                        node[left]{$a$}
                                    }
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$c$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[left]{$c$}
            }
            edge from parent[dotted]
            node[right]{$g$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent[dotted]
                    node[left]{$c$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            edge from parent
            node[left]{$g$}
        }
        edge from parent
        node[left]{$c$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent[dotted]
                node[left]{$c$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$a$}
                            }
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$c$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent[dotted]
            node[right]{$c$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Position Suffix Tree -> Compact Suffix Tree------------------------
\begin{frame}
\frametitle{Position Suffix Tree $\rightarrow$ Compact Suffix Tree}
$pst$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 20mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$cgag$}
        }
        child {
            edge from parent
            node[right]{$gcgacgag$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent[solid]
                    node[left]{$cgag$}
                }
                child {
                    edge from parent[solid]
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            edge from parent
            node[left]{$g$}
        }
        edge from parent[dotted]
        node[left]{$c$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            edge from parent
            node[right]{$cgacgag$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}

$cst$ für die Zeichenkette $agcgacgag$.
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$cgag$}
        }
        child {
            edge from parent
            node[right]{$gcgacgag$}
        }
        edge from parent
        node[above]{$a$}
    }
    child[level distance = 16mm] {
        node[branch]{}
        child {
            edge from parent
            node[left]{$cgag$}
        }
        child {
            edge from parent
            node[right]{$g$}
        }
        edge from parent
        node[left]{$cga$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            edge from parent
            node[right]{$cgacgag$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Suffix Tree Klassen------------------------------------------------
\begin{frame}[t]
\frametitle{Suffix Tree Klassen}
\begin{definition}
Sei $S_t$ ein Suffix Tree für ein Wort $t$, repräsentiert durch seine Kantenmenge $E$ und $n = \abs{t}$. $S_t$ wird bezeichnet als:
\begin{itemize}
    \item Atomic Suffix Tree, wenn $\abs{E}$ maximal ist.
    \item Position Suffix Tree, wenn die Länge aller inneren Kantenbeschriftungen $1$ beträgt.
    \item Compact Suffix Tree, wenn $\abs{E}$ minimal ist.
\end{itemize}
\end{definition}
\begin{lemma}
    Seien $T_1$ und $T_2$ $\Sigma^+$-Bäume mit $T_1 \implies T_2$. Dann enthält $T_1$ genau dann das Wort $w$, wenn $T_2$ das Wort $w$ enthält.
\end{lemma}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Speicherplatzbedarf------------------------------------------------
\begin{frame}
\frametitle{Speicherplatzbedarf}
% TODO Folie Speicherplatzbedarf ausarbeiten!
\begin{lemma}
    cst kann als eine Datentruktur dargestellt werden, deren Speicherplatzbedarf $O(n)$ ist.
\end{lemma}
\begin{proof}
    \begin{itemize}
        \item cst hat nicht mehr als $n$ Blätter\footnote{abhängig davon, ob man Leafs zählt... erklären}. 
        \item jeder innere Knoten ist eine Verzweigung, die Anzahl von Blätter mindestens um 1 erhöht.
    \end{itemize}
    $\rightarrow$ 
    cst hat nicht mehr als $n$ innere Knoten und damit nicht mehr als $2n$ Kanten.
\end{proof}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsection{Anwendungsgebiete}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Anwendungsgebiete--------------------------------------------------
\begin{frame}
\frametitle{Anwendungsgebiete}
Suffix Trees eignen sich insbesondere für Problemlösungen im Bereich der Stringverarbeitung.
\begin{figure}
\begin{tabular}{l}
    \toprule
    All-pairs suffix-prefix matching      \\
    Common substrings of multiple strings \\
    Construction of DAWGs                 \\
    Exact set matching                    \\
    Exact string matching                 \\
    \textbf{k-mismatch}                   \\
    Longest common substring              \\
    Matching statistics                   \\
    Maximal repeated pairs                \\
    Maximal repeats                       \\
    Supermaximal repeats                  \\
    Ziv–Lempel decomposition              \\
    ...                                   \\
    \bottomrule
\end{tabular}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

% TODO Ein Anwendungsgebiet auswählen und vorstellen!

%////////////////////////////////////////////////////////////////////////////
\subsection{Geschichte}
%////////////////////////////////////////////////////////////////////////////

% TODO Morrison (1968)
% TODO Weiner (1973)
% TODO McCreight (1976)
% TODO Ukkonen (1995)
% TODO Giegerich & Kurtz (1999)

%////////////////////////////////////////////////////////////////////////////
\subsection{wotd-Algorithmus}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\subsubsection{Beispiel}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Beispiel-----------------------------------------------------------
\begin{frame}
\frametitle{Beispiel für $agcgacgag$}
\begin{tabularx}{\textwidth}{L X}
    Suffixe &  $agcgacgag$, $gcgacgag$, $cgacgag$, $gacgag$, $acgag$, $cgag$, $gag$, $ag$, $g$
\end{tabularx}
\begin{table}
    \begin{tabular}{l l l}
        \toprule
        Gruppe 1                 & Gruppe 2               & Gruppe 3                \\
        \midrule
        $\boldsymbol{a}gcgacgag$ & $\boldsymbol{cga}cgag$ & $\boldsymbol{g}cgacgag$ \\
        $\boldsymbol{a}cgag$     & $\boldsymbol{cga}g$    & $\boldsymbol{g}acgag$   \\
        $\boldsymbol{a}g$        &                        & $\boldsymbol{g}ag$      \\
                                 &                        & $\boldsymbol{g}$        \\
        \midrule
        $a$                      & $cga$                  & $g$                     \\
        \bottomrule
    \end{tabular}
\end{table}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Beispiel-----------------------------------------------------------
\begin{frame}
\frametitle{Beispiel für $agcgacgag$}
Erstes Level
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [yshift = 3.5cm]
        \node[branch]{}
        child {
            node[ghostbranch] (u) {}
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 8mm] {
            node[ghostbranch] (v) {}
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[ghostbranch] (w) {}
            edge from parent
            node[above]{$g$}
        };
        \node[align = left, anchor = north, yshift = {-1mm}] at (u.center) {$gcgacgag$ \\ $cgag$ \\ $g$};
        \node[align = left, anchor = north, yshift = {-1mm}] at (v.center) {$cgag$ \\ $g$};
        \node[align = left, anchor = north, yshift = {-1mm}] at (w.center) {$cgacgag$ \\ $acgag$ \\ $ag$};
    }
\end{tikzpicture}
\end{figure}
Die gebliebene Wörter werden wieder in Gruppen geteilt. Aus der ersten Gruppe werden folgende zwei teilgruppen erzeugt:
\begin{table}
    \begin{tabular}{l l}
        \toprule
        Gruppe 1                 & Gruppe 2               \\
        \midrule
        $\boldsymbol{g}cgacgag$  & $\boldsymbol{cgag}$    \\
        $\boldsymbol{g}$         &                        \\
        \midrule
        $gcgacgag$\footnote{Falls nur $g$ als das gemeinsame Präfix genommen wurde, dann hätte \\ man eine unnötige Kante im Baum}                         & $cgag$                 \\
        \bottomrule
    \end{tabular}
\end{table}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Beispiel-----------------------------------------------------------
\begin{frame}[t]
\frametitle{Beispiel für $agcgacgag$}
Zweites und drittes Level
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [yshift = 0cm]
        \node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 16mm] {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[branch]{}
            child {
                node[ghostbranch] (u) {}
                edge from parent
                node[left]{$a$}
            }
            child {
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
        \node[align = left, anchor = north, yshift = {-1mm}] at (u.center) {$cgag$ \\ $g$};
    }
\end{tikzpicture}
\end{figure}
\begin{figure}
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    \draw[dotted] (-4.5, 0.75) -- (5, 0.75);
    { [yshift = 0cm]
        \node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 16mm] {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent
                    node[left]{$cgag$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
    }
\end{tikzpicture}
\end{figure}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsubsection{Vorgehensweise}
%////////////////////////////////////////////////////////////////////////////

%--Folie: wotd-Algorithmus: Schritte-----------------------------------------
\begin{frame}[t]
\frametitle{wotd-Algorithmus für cst}
    wotd: write-only top-down\\
    \medskip
    Schritte:
    \begin{enumerate}
        \item Finde alle Suffixe eines gegebenen Wortes.
        \item Gruppiere nach den Anfangsbuchstaben. Erzeuge einen Knoten.
        \item Für jede Gruppe:
        \begin{enumerate}
            \item Finde das längste gemeinsame Präfix\footnote{When ein Wort der Gruppe sich endet, wird das Präfix weiter gesucht}, erzeuge eine Kante mit der Beschriftung vom Präfix, entferne das Präfix von den Wörtern der Gruppe.
            \item Falls die Gruppe leer ist, erzeuge ein Blatt. Falls es in der Gruppe noch Wörter gibt, kehre zu Schritt 2 zurück.
        \end{enumerate}
    \end{enumerate}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell: List comprehension----------------------------------------
\begin{frame}[fragile]
\frametitle{Haskell: List comprehension}
List comprehensions ermöglichen es in Anlehnung an die mathematische Mengennotation Listen auf eine prägnante Art und Weise zu erzeugen.
$$\{(i,j)\vert \: i \in \{1, 2\},\: j \in \{1, \dots, 4\}\}$$
ist äquivalent zu
$$[(i, j)\vert\: i \leftarrow [1,2],\: j \leftarrow [1..4]]$$
Syntax: $[e \:\vert\: q_1, \dots, q_n], n \geq 1$ , wobei die $q_i$ entweder
\begin{itemize}
    \item Generatoren, z. B. $i \leftarrow \left[1..4\right]$
    \item lokale Definitionen, z. B. $let\:i = x * x$
    \item Prädikate, z. B. $x > 2$
\end{itemize}
sind.
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell: List comprehension----------------------------------------
\begin{frame}[t, fragile]
\frametitle{Haskell: List comprehension}
\begin{examples}
\begin{enumerate}
\item Mit Prädikat
\begin{lstlisting}
[2*x | x <- [0..10], x^2 > 5]
-- ergibt
[6,8,10,12,14,16,18,20]
\end{lstlisting}
\item Mit lokaler Definition
\begin{lstlisting}
[(i,j) | i <- [1,2], let k = i*i, 
         j <- [1..k]]
-- ergibt
[(1,1),(2,1),(2,2),(2,3),(2,4)]
\end{lstlisting}
\end{enumerate}
\end{examples}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsubsection{Haskell-code}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Haskell-code: Typdefinitionen--------------------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Typdefinitionen}
\begin{lstlisting}
-- | Darstellung von Suffix Trees
data STree alf = 
    Leaf | Branch [(Label alf,STree alf)] 
    deriving Eq

-- | Darstellung von Beschriftungen
type Label alf = [alf]

-- | Darstellung vom Kantenaufbau
type EdgeFunction alf = [[alf]] -> 
                        ([alf],[[alf]])
\end{lstlisting}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell-code: Liste von Suffixen-----------------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Liste von Suffixen}
Folgende Funktion liefert alle Suffixe von dem gegebenen Wort $aw$:
\begin{lstlisting}
suffixes :: [alf] -> [[alf]]
suffixes []       = []
suffixes aw@(_:w) = aw:suffixes w
\end{lstlisting}
\bigskip
\begin{remark}
\begin{description}[l]
    \item[Operator $(::)$] Typ-Spezifikations-Operator
    \item[Operator $(:)$] Cons-Operator: Erzeugt aus einer Liste $l$ und einem Element $h$ eine neue Liste, indem das Element $h$ der Liste $l$ vorangestellt wird.
    \item[Operator $(@)$] Read-As-Operator: $aw@(\_:w)$ bedeutet, dass $aw$ mit $(\_:w)$ gematcht wird.
\end{description}
\end{remark}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell-code: Auswahl----------------------------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Auswahl einer Gruppe}
    Folgende Funktion liefert die Liste mit allen Wörter aus $ss$, die mit $a$ anfangen:
\begin{lstlisting}
select :: (Eq alf) => 
          [[alf]] -> alf -> [[alf]]
select ss a = [c:u | c:u <- ss, a == c]
\end{lstlisting}
\bigskip
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell-code: Kantenerzeugung--------------------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Kantenerzeugung}
Folgende Funktion erzeugt die Kante mit der längster-Präfix- Beschriftung für eine gegebene Liste von Wörter:
\begin{lstlisting}
edge :: (Eq alf) => EdgeFunction alf
edge [s] = ([s], [[]])
edge awss@((a:_):ss)
 | all (\c:_ -> a == c) ss = (a:cp, rss)
 | otherwise               = ([], awss)
 where (cp, rss) = edge ([t | _:t <- awss, length t > 0])
\end{lstlisting}
\bigskip
\begin{remark}
\begin{lstlisting}
all :: (a -> Bool) -> [a] -> Bool
all p [] = true
all p x:xs = p x && all p xs
\end{lstlisting}
\end{remark}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell-code: Baumaufbau-------------------------------------------
\begin{frame}[fragile]
\frametitle{Haskell-code: Baumaufbau}
Die folgende Funktion baut den cst-Baum auf:
\begin{lstlisting}
lazy_cst ::(Eq alf) => (EdgeFunction alf) -> [alf] -> [alf] -> STree alf

lazy_cst edge alpha t = sTr (suffixes t) 
 where
 sTr [[]] = Leaf
 sTr ss   = Branch[(cp,sTr rss) |
                   a <- alpha,
                   let gs = select ss a,
                   length gs > 0,
                   let (cp,rss) = edge gs
                   ]
\end{lstlisting}
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\subsection{Suche in Bäumen}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Haskell-Code: commonPrefix für die Suche---------------------------
\begin{frame}[fragile]
\frametitle{Suche in Bäumen}
Hilfsfunktion:
\begin{lstlisting}
commonPrefix :: 
 (Eq alph) => Word alph -> Word alph -> 
 (Word alph, Word alph, Word alph)

commonPrefix w1 w2 = g w1 w2 []
 where
 g (x:xs) (y:ys) cp | (x == y) = 
                      g xs ys (x:cp)
 g w1 w2 cp  = (w1, w2, reverse cp)
\end{lstlisting}
\end{frame}
%--Folie---------------------------------------------------------------------

%--Folie: Haskell-Code: Suche------------------------------------------------
\begin{frame}[fragile]
\frametitle{Suche in Bäumen}
\begin{lstlisting}
search :: (Eq alph) => 
          Word alph -> STree alph -> Bool

search ss Leaf        = False
search ss (Branch es) =  g ss es
    where g ss (((l, st):es)) = 
            case commonPrefix ss l of
            ([], _, _)   -> True
            (_, _, [])   -> g ss es
            (ss', [], _) -> search ss' st
            _            -> False
\end{lstlisting}
\end{frame}
%--Folie---------------------------------------------------------------------


%////////////////////////////////////////////////////////////////////////////
\subsubsection{Laufzeitanalyse}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Laufzeitanalyse----------------------------------------------------
\begin{frame}[fragile]
\frametitle{Laufzeitanalyse}
% TODO Laufzeitanalyse
\end{frame}
%--Folie---------------------------------------------------------------------

%////////////////////////////////////////////////////////////////////////////
\section{Suffix Array}
%////////////////////////////////////////////////////////////////////////////

%--Folie: Motiviation--------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivation}
% TODO Folie Motivation für Suffix Arrays ausarbeiten!
\end{frame}
%--Folie---------------------------------------------------------------------

% TODO Kapitel Suffix Arrays ausarbeiten!
\end{document}
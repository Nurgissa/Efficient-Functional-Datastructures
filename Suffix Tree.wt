== Grundlegende Begriffe ==

===== Definition $t$-Wort =====

Sei $t \in \Sigma^*$ mit $t = uvw$. Dann ist $v$ ein $t$-Wort.

===== Definition Verzweigung =====

Ein $t$-Wort wird Verzweigung genannt, wenn zwei unterschiedliche Buchstaben $a$ und $c$ existieren, sodass $va$ und $vc$ $t$-Wörter sind.

===== Definition verschachteltes Suffix =====

Ein Suffix von $t$ heißt verschachtelt, wenn es mehrmals in $t$ vorkommt.

===== Definition verschachteltes Präfix =====

Sei $s$ ein Suffix von $t$. Ein Präfix $p$ von $s$ heißt verschachtelt, genau dann wenn ein Suffix $s'$ existiert, sodass $|s'| > |s|$ und $p$ ein Präfix von $s'$ ist.

===== Definition $\Sigma^+$-Baum =====

$\Sigma^+$-Baum ist ein Baum mit Kantenbeschriftungen aus $\Sigma^+$. Für alle $a \in \Sigma$ existiert höchstens eine $a$-Kante mit $k \xrightarrow{aw} k'$. Die Menge aller $\Sigma^+$-Bäume bezeichnen wir mit $T\:(\Sigma^+)$.

===== Definition Pfad =====

$path\:(k)$ bezeichnet die Konkatenation der Kantenbeschriftungen von der Wurzel bis zum Knoten $k$. Anstatt $k$ schreibt man $\bar{w}$ genau dann, wenn $path\:(k) = w$.

===== Definition Suffixbaum =====

Ein Suffixbaum $S_t$ für ein gegebenes Wort $t$ ist ein $\Sigma^+$-Baum, so dass alle $t$-Wörter in $S_t$ enthalten sind. 

===== Definition Kanteneleminierung =====

Sei $\bar{s}$, $\bar{w}$, $\bar{v} \in \Sigma^+$-Baum. Die Kanteneleminierung ist eine Relation auf $\Sigma^+$-Bäumen: $\{\bar{s}\:\xrightarrow{u}\:\bar{w},\bar{w}\:\xrightarrow{u'}\:\bar{v}\} \overset{\bar{w}}{\implies} \{\bar{s}\:\xrightarrow{uu'}\:\bar{v}\}$ mit $\bar{w} \xrightarrow{u'} \bar{v}$ ist die einzige ausgehende Kante von $\bar{w}$.

===== Lemma =====

Seien $E, E' \in T\:(\Sigma^+)$ mit $E \implies E'$. Dann enthält $E$ genau dann das Wort $w$, wenn $E'$ das Wort $w$ enthält.

===== Formen von Suffixbäumen =====

Sei $S_t$ ein Suffixbaum für $t$, repräsentiert durch die Menge seiner Kanten $E$ und $n = |t|$.

# $S_t$ wird als atomarer Suffixbaum $ast\:(t)$ bezeichnet, wenn $|E|$ maximal ist. Ein $ast\:(t)$ besitzt $O\:(n^2)$ Knoten im Worst Case. 
# $S_t$ wird als Positions-Suffixbaum $pst\:(t)$ bezeichnet, wenn die Länge alle inneren Kantenbeschriftungen 1 beträgt. Ein $pst\:(t)$ besitzt $O\:(n^2)$ Knoten im Worst Case.
# $S_t$ wird als kompakter Suffixbaum $cst\:(t)$ bezeichnet, wenn $|E|$ minimal ist. Ein $cst\:(t)$ besitzt $O\:(n)$ im Worst Case.

== Suffixbaumkonstruktion ==

=== Lazy Tree ===

<pre>
module LazyTreeExt where

import Data.List

-- | Suffix tree representation
data STree alf = Leaf | Branch [(Label alf, STree alf)] deriving Eq

-- | Suffix tree label representation
type Label alf = [alf]

-- | Type of edge functions
type EdgeFunction alf = [[alf]] -> ([alf], [[alf]])

lazy_cst :: (Eq alf) => [alf] -> [alf] -> STree alf
lazy_cst = lazyTree edge_cst

-- | Builds a suffix tree for the word @t@.
lazyTree :: (Eq alf) => (EdgeFunction alf) -> [alf] -> [alf] -> STree alf
lazyTree edge alpha t = sTr (suffixes t)
    where sTr [[]] = Leaf
          sTr ss   = Branch [(cp, sTr ssr) | a <- alpha,
                                             let gs = select ss a,
                                             let (cp, ssr) = edge gs]

-- | Returns a list with all words of @ss@, which starts with the letter @a@.
select :: (Eq alf) => [[alf]] -> alf -> [[alf]]
select ss a = [c:u | c:u <- ss, a == c]

-- | Returns a list with all suffixes of the given word.
suffixes :: [alf] -> [[alf]]
suffixes []       = []
suffixes aw@(_:w) = aw:suffixes w

-- | edge function for building a cst.
edge_cst :: (Eq alf) => EdgeFunction alf
edge_cst [s] = ([s], [[]])
edge_cst awss@((a:_):ss) | all (\c:_ -> a == c) ss = (a:cp, rss)
                         | otherwise               = ([], awss)
                           where (cp, rss) = edge_cst ([t | _:t <- awss])
</pre>
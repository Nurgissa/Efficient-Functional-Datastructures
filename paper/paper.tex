%////////////////////////////////////////////////////////////////////////////
% Ausarbeitung "Suffix Trees und Suffix Arrays"
%////////////////////////////////////////////////////////////////////////////

% Autoren   : Simon Kaltenbacher, Evgeny Novoseltsev
% Semester  : WS 11/12
% Vorlesung : Effiziente funktionale Datenstrukturen
% Betreuer  : Prof. Martin Hofmann, PhD

%////////////////////////////////////////////////////////////////////////////

\documentclass[12pt]{report}

%////////////////////////////////////////////////////////////////////////////
% Import
%////////////////////////////////////////////////////////////////////////////

\usepackage{graphicx}    % needed for including graphics e.g. EPS, PS
\usepackage[ngerman]{babel}
\usepackage{textcomp}
% Umlaute in Ausgabedokument anzeigen
\usepackage[T1]{fontenc}
% Kodierung festlegen
%\usepackage{ucs}
\usepackage[utf8]{inputenc}
% Mathematische Notationen
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathtools, xfrac}
% Code von Programmiersprachen erkennen
% \usepackage{courier}
\usepackage{inconsolata}
\usepackage{listings, xcolor}
% Bäume zeichnen
\usepackage{tikz}
\usepackage{caption}
% Tabellen
\usepackage{booktabs}
\usepackage{tabularx}
% Überschriften in der Kopfzeile
\usepackage{fancyhdr}
% Literaturverzeichnis
\usepackage[numbers, square]{natbib}

%////////////////////////////////////////////////////////////////////////////
% Konfiguration
%////////////////////////////////////////////////////////////////////////////

%--Article Konfiguration-----------------------------------------------------

\topmargin -1.5cm        % read Lamport p.163
\oddsidemargin -0.04cm   % read Lamport p.163
\evensidemargin -0.04cm  % same as oddsidemargin but for left-hand pages
\textwidth 16.59cm
\textheight 21.94cm
%\pagestyle{empty}       % Uncomment if don't want page numbers
\parskip 7.2pt           % sets spacing between paragraphs
%\renewcommand{\baselinestretch}{1.5} 	% Uncomment for 1.5 spacing between lines
\parindent 0pt		  	 % sets leading space for paragraphs

%--Figure-Konfiguration------------------------------------------------------

\setlength{\abovecaptionskip}{5mm}

%--Paragraph Format----------------------------------------------------------
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
    {-3.25ex\@plus -1ex \@minus -.2ex}%
    {1.5ex \@plus .2ex}%
    {\normalfont\normalsize\bfseries}}
\makeatother

%--Fancyheadings-Konfiguration-----------------------------------------------

\pagestyle{fancy}

%--Farben--------------------------------------------------------------------

\definecolor{verylightgray}{RGB}{230, 230, 230}
\definecolor{rubinered}{RGB}{243, 0, 125}
\definecolor{aquamarine}{RGB}{0, 193, 223}

%--listings-Konfiguration----------------------------------------------------

\definecolor{verylightgray}{RGB}{230, 230, 230}
\lstloadlanguages{Haskell}
\lstset {
    language = Haskell,
    tabsize = 4,
    showstringspaces = false,
    breaklines = true,
    basicstyle = \ttfamily\fontsize{11}{11}\selectfont,
    keywordstyle = \color{blue},
    commentstyle = \color{darkgray},
    framesep = 2mm,
    rulecolor = \color{black},
    frame = lines,
    extendedchars = true,
    framextopmargin = 5pt,
    xleftmargin = 5pt,
    framexleftmargin = 5pt,
    framexrightmargin = 5pt,
    framexbottommargin = 5pt,
}

%--TikZ Konfiguration--------------------------------------------------------

\usetikzlibrary{trees, calc, shapes, scopes}

%--Styledefinitionen für Suffix Trees----------------------------------------

\tikzstyle{branch} = [
    shape = circle,
    minimum size = 1mm,
    inner sep = 0mm,
    outer sep = 0.5mm,
    fill
]
\tikzstyle{ghostbranch} = [
    shape = circle,
    draw,
    minimum size = 1mm,
    inner sep = 0mm,
    outer sep = 0.5mm
]
\tikzstyle{leaf} = [
    inner sep = 0mm,
    outer sep = 0mm
]
\tikzstyle{subtree} = [
    isosceles triangle,
    dotted,
    draw,
    shape border rotate = 90,
    isosceles triangle stretches = true,
    minimum height = 10mm,
    minimum width = 10mm,
    inner sep = 0,
    anchor = north,
    font = \tiny
]

%--Literaturverzeichnis------------------------------------------------------

% Literaturverzeichnis Stil
\bibliographystyle{alpha}

%--Benutzerdefinierte Makros-------------------------------------------------

% Umgebung Bemerkung
\newtheorem{remark}{Bemerkung}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem*{problem}{Problemstellung}

\newcommand{\coloneqq}{\mathrel{\mathop:}=}

\newcommand{\abs}[1]{\left|#1\right|}

%////////////////////////////////////////////////////////////////////////////
% Dokumenteigenschaften
%////////////////////////////////////////////////////////////////////////////

% Titel
\title{Suffix Trees und Suffix Arrays}

% Autoren
\author{Simon Kaltenbacher, Evgeny Novoseltsev}

% Erstellungsdatum
\date{\today}

%////////////////////////////////////////////////////////////////////////////
% Dokument
%////////////////////////////////////////////////////////////////////////////

\begin{document}

%--Seite: Titel--------------------------------------------------------------
\maketitle

%--Seite: Inhaltsverzeichnis-------------------------------------------------
\tableofcontents

\begin{abstract}
TODO: Einleitung
\end{abstract}

%////////////////////////////////////////////////////////////////////////////
\chapter{Suffix Tree}
\label{chap:SuffixTree}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\section{Terminologie}
\label{sec:Terminologie}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\subsection{Grundlagen}
\label{sec:Grundlagen}
%////////////////////////////////////////////////////////////////////////////

Zunächst möchten wir auf die grundlegende Notation eingehen, die in dieser Abhandlung Verwendung findet.

Sei $\Sigma$ ein endliches Alphabet. Das leere Wort bezeichnen wir mit $\epsilon$. Wie gewohnt bezeichnet $\Sigma^*$ die Kleen'sche Hülle von $\Sigma$ und $\Sigma^+ \coloneqq \Sigma^* \setminus \{\epsilon\}$. Zur besseren Übersichtlichkeit verwenden wir im Folgenden $a - g$ auschließlich für Buchstaben aus $\Sigma$ und $t - z$ für Wörter über $\Sigma^*$. Mit $uv$ bezeichnen wir die Konkatenation der Wörter $u$ und $v$.

\begin{definition}[Präfix, Suffix, $t$-Wort]
Sei $t = uvw$ mit $u, v, w \in \Sigma^*$. Dann ist $u$ ein Präfix und $w$ ein Suffix von $t$. $v$ wird als $t$-Wort bezeichnet.
\end{definition}

\begin{definition}[$\Sigma^+$-Baum]
Ein $\Sigma^+$-Baum ist ein Baum, dessen Kanten mit Wörtern aus $\Sigma^+$ beschriftet sind. Die Kanten eines $\Sigma^+$-Baums erfüllen folgendes Eindeutigkeitskriterium: Für alle Kanten $k \xrightarrow{aw} k'$ und $k \xrightarrow{bv} k''$ folgt $a = b$.
\label{def:SigmaPlusBaum}
\end{definition}

Abb. \ref{fig:SigmaPlusTree} zeigt einen $\Sigma^+$-Baum für das Alphabet $\Sigma = \{a, \dots, g \}$. Um im weiteren Verlauf besser über diese Art von Bäumen und ihre Bestandteile sprechen zu können, benötigen wir noch eine Reihe von nützlichen Definitionen.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 35mm},
    level 2/.style = {level distance = 10mm, sibling distance = 25mm},
    level 3/.style = {level distance = 10mm, sibling distance = 20mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$ad$}
        }
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[right, yshift = 0.5mm]{$gd$}
        }
        edge from parent
        node[above]{$ad$}
    }
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$a$}
        }
        edge from parent
        node[left]{$cg$}
    }
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$ga$}
        }
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[right, yshift = 0.5mm]{$ad$}
        }
        edge from parent
        node[above]{$gac$}
    };
\end{tikzpicture}
\caption{$\Sigma^+$-Baum für $\Sigma = \{a, \dots, g\}$}
\label{fig:SigmaPlusTree}
\end{figure}

\begin{definition}[Pfad]
Die Funktion $path(k)$ bezeichnet die Konkatenation der Kantenbeschriftungen von der Wurzel bis zum Knoten $k$.
\label{def:Pfad}
\end{definition}

Mithilfe der obigen Definition \ref{def:Pfad}, lässt sich eine elegante Notation für die Bezeichnung von Knoten eines $\Sigma^+$-Baumes einführen\footnote{Diese Notation wird in \cite{Ukkonen1995} eingeführt.}. Mit $\overline{w}$ bezeichnen wir genau dann einen Knoten $k$, wenn $path(k) = w$. Dieser Zusammenhang wird in Abb. \ref{fig:NotationZurKnotenbezeichnung} veranschaulicht.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 35mm},
    level 2/.style = {level distance = 10mm, sibling distance = 25mm},
    level 3/.style = {level distance = 10mm, sibling distance = 20mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch] {}
    child[child anchor = north] {
        node[subtree] {}
        edge from parent[dotted]
    }
    child {
        node[branch] {}
        child {
            node (n) [branch] {}
            child[child anchor = north] {
                node[subtree] {}
                edge from parent[dotted]
            }
            child[child anchor = north] {
                node[subtree] {}
                edge from parent[dotted]
            }
            edge from parent
            node[right] {$u$}
        }
        edge from parent
        node[left] {$v$}
    }
    child[child anchor = north] {
        node[subtree] {}
        edge from parent[dotted]
    };
    \node[left = 2mm] at (n) {$\overline{vu}$};
\end{tikzpicture}
\caption{Notation zur Knotenbezeichnung}
\label{fig:NotationZurKnotenbezeichnung}
\end{figure}

Einen Knoten $\overline{w}$ nennen wir Verzweigung, wenn von ihm mehr als eine Kante ausgeht. Alle Kanten, die nicht zu einem Blattknoten führen, bezeichnen wir als innere Kanten eines Baumes. Ein Wort $w$ ist genau dann in einem $\Sigma^+$-Baum $T$ enthalten, wenn ein Knoten $\overline{wu}$ in diesem Baum existiert, d.h. $w$ ist Präfix eines Wortes, dass durch die Konkatenation der Kantenbeschriftungen eines Pfades in $T$ gebildet werden kann.

%////////////////////////////////////////////////////////////////////////////
\subsection{Suffix Tree Klassen}
\label{sec:suffixTreeKlassen}
%////////////////////////////////////////////////////////////////////////////

Zu Beginn dieses Abschnitts geben wir eine allgemeine Definition für Suffix Trees, die später durch den Begriff der Suffix Tree Klassen\footnote{Diese Art der Klassifizierung von Suffix Trees stammt aus \cite{Giegerich1995}.} weiter differenziert wird.

Suffix Trees bilden eine Teilmenge der $\Sigma^+$-Bäume. Analog zu anderen Suchbäumen ist auch der Aufbau des Suffix Tree durch die Anforderungen an die Suchoperation motiviert. Suffix Trees wurden primär für das Problem der exakten Teilwortsuche entwickelt, welches in Kapitel \ref{sec:Teilwortsuche} detailliert behandelt wird. Man nutzt hier die Tatsache, dass sich jedes Teilwort $w$ eines Wortes $t$ als Präfix eines Suffix darstellen lässt:
\begin{gather*}
    t = a \dots b \underbrace{\overbrace{c \dots d}^{\text{Präfix }w} e \dots f}_{\text{Suffix }s}
\end{gather*}
Somit kann das Problem der exakten Teilwortsuche auf eine Präfixsuche auf den Suffixen eines Wortes zurückgeführt werden. Diese Beobachtung führt zur zentralen Charakteristik von Suffix Trees, die in Abb. \ref{fig:suffixTreeAgcgacgag} leicht zu erkennen ist. Jeder Pfad von der Wurzel bis zu einem Blatt des Baumes korrespondiert mit einem Suffix des Wortes, für das der Suffix Tree aufgebaut wurde. Diese Überlegungen führen zu folgender formalen Definition für Suffix Trees.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 45mm},
    level 2/.style = {level distance = 10mm, sibling distance = 25mm},
    level 3/.style = {level distance = 10mm, sibling distance = 15mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$cgag$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$gcgacgag$}
        }
        edge from parent
        node[above]{$a$}
    }
    child[level distance = 16mm] {
        node[branch]{}
        child {
            node[leaf] {}
            edge from parent
            node[left]{$cgag$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$g$}
        }
        edge from parent
        node[left]{$cga$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[leaf] {}
                edge from parent
                node[left]{$cgag$}
            }
            child {
                node[leaf] {}
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$cgacgag$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\caption{Suffix Tree für die Zeichenkette $agcgacgag$}
\label{fig:suffixTreeAgcgacgag}
\end{figure}

\begin{definition}[Suffix Tree\footnote{Auf diese Art und Weise werden Suffix Trees in \cite{Giegerich1995} definiert.}]
Ein Suffix Tree $S_t$ für ein gegebenes Wort $t$ ist ein $\Sigma^+$-Baum, sodass gilt:
\begin{gather*}
    w \in S_t \Longleftrightarrow w \text{ ist ein }t\text{-Wort}
\end{gather*}
\label{def:SuffixTree}
\end{definition}

Ausgehend von dieser allgemeinen Definition, werden Suffix Trees abhängig von der Anzahl ihrer Kanten nochmals in drei verschiedene Klassen unterteilt. Zur Unterscheidung dieser Klassen betrachten wir die Kantenmengen der Suffix Trees. Ein Suffix Tree $S_t$ für ein Wort $t$, repräsentiert durch seine Kantenmenge $E$ heißt
\begin{enumerate}
    \item Atomic Suffix Tree $ast$, wenn $\abs{E}$ maximal ist.
    \item Position Suffix Tree $pst$, wenn die Länge aller inneren Kantenbeschriftungen $1$ beträgt.
    \item Compact Suffix Tree $cst$, wenn $\abs{E}$ minimal ist
\end{enumerate}
Die drei Suffix Tree Formen stehen in Relation bezüglich Kantenverschmelzung.

\begin{definition}[Kantenverschmelzung]
Kantenverschmelzung ist eine Relation auf $\Sigma^+$-Bäumen, die durch ihre Kantenmengen repräsentiert werden.
\begin{gather*}
    \left(E \uplus \{\overline{s}\:\xrightarrow{u}\:\overline{w},\overline{w}\:\xrightarrow{u'}\:\overline{v}\}\right) \overset{\overline{w}}{\implies} \left(E \uplus \{\overline{s}\:\xrightarrow{uu'}\:\overline{v}\}\right)
\end{gather*}
wenn $\overline{w} \xrightarrow{u'} \overline{v}$ ist die einzige ausgehende Kante von $\overline{w}$. Die Umkehrrelation bezeichnen wir als Kantenteilung.
\end{definition}
Abb. \ref{fig:Kantenverschmelzung} zeigt, wie der Knoten $w$ mittels Kantenverschmelzung aus dem Baum entfernt wird. Es ist darauf zu achten, dass der Knoten $w$ keine Verzweigung ist.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 40mm},
    level 2/.style = {level distance = 10mm, sibling distance = 30mm},
    level 3/.style = {level distance = 10mm, sibling distance = 20mm},
    edge from parent/.style = {->, draw}
    ]
    { [xshift = 0cm, yshift = 0cm]
        \node {}
        child {
            node[branch] (s1) {}
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            child {
                node[branch] (w1) {}
                child {
                    node[branch] (v1) {}
                    edge from parent
                    node[left]{$u'$}
                }
                edge from parent[solid]
                node[left]{$u$}
            }
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            edge from parent[dotted]
        };
    }
    \node[subtree] at (v1.center) {};
    \node[yshift = 2mm, xshift = 3mm] at (s1.center) {$\overline{s}$};
    \node[right] at (w1.east) {$\overline{w}$};
    \node[right] at (v1.center) {$\overline{v}$};
    { [xshift = 4cm, yshift = {-1cm}]
        \node{$\overset{\overline{w}}{\implies}$};
    }
    { [xshift = 8cm, yshift = 0cm]
        \node{}
        child {
            node[branch] (s2) {}
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            child[level distance = 12mm] {
                node[branch] (v2) {}
                edge from parent[solid]
                node[left]{$uu'$}
            }
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            edge from parent[dotted]
        };
    }
    \node[subtree] at (v2.center) {};
    \node[yshift = 2mm, xshift = 3mm] at (s2.center) {$\overline{s}$};
    \node[right] at (v2.center) {$\overline{v}$};
\end{tikzpicture}
\caption{Kantenverschmelzung}
\label{fig:Kantenverschmelzung}
\end{figure}

Während $ast$ eine Normalform bezüglich Kantenteilung und $cst$ eine Normalform bezüglich Kantenverschmelzung darstellen, repräsentiert der $pst$ ein Hybridstadium zwischen $ast$ und $pst$. Abb. \ref{fig:SuffixTreeKlassen} zeigt alle drei Suffix Tree Klassen für diesselbe Zeichenkette $agcgacgag$.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 25mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [xshift = 0cm, yshift = 0cm]
        \node[branch] (root) {}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$c$}
                }
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    node[branch]{}
                                        child {
                                            node[branch]{}
                                            child {
                                                edge from parent
                                                node[left]{$g$}
                                            }
                                            edge from parent
                                            node[left]{$a$}
                                        }
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$c$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$c$}
                }
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[above]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$a$}
                            }
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$c$}
                    }
                    child {
                        edge from parent
                        node[right]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$c$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    node[branch]{}
                                    child {
                                        edge from parent
                                        node[left]{$g$}
                                    }
                                    edge from parent
                                    node[left]{$a$}
                                }
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$c$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[right]{$c$}
            }
            edge from parent
            node[above]{$g$}
        };
        \node[left = 2cm, yshift = 2mm] at (root) {$\boldsymbol{ast}$};
    }
    { [xshift = 8cm, yshift = 0cm]
        \node[branch] (root) {}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        edge from parent
                        node[left]{$cgag$}
                    }
                    child {
                        edge from parent
                        node[right]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent
                    node[left]{$cgag$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
        \node[left = 2cm, yshift = 2mm] at (root) {$\boldsymbol{pst}$};
    }
    { [xshift = 8cm, yshift = -3.5cm]
        \node[branch] (root) {}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                node[leaf] {}
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 22mm] {
            node[branch]{}
            child {
                node[leaf] {}
                edge from parent
                node[left]{$cgag$}
            }
            child {
                node[leaf] {}
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left, yshift = -5mm]{$cga$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[leaf] {}
                    edge from parent
                    node[left]{$cgag$}
                }
                child {
                    node[leaf] {}
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                node[leaf] {}
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
        \node[left = 2cm, yshift = 2mm] at (root) {$\boldsymbol{cst}$};
    }
\end{tikzpicture}
\caption{Suffix Tree Klassen: $ast$, $pst$ und $cst$ für die Zeichenkette $agcgacgag$}
\label{fig:SuffixTreeKlassen}
\end{figure}

Zum Abschluss dieses Abschnitts möchten wir auf die Speicherplatzkomplexität der Suffix Tree Klassen eingehen.

\begin{lemma}[Speicherplatzkomplexität]
$cst$ besitzt eine Speicherplatzkomplexität von $O(n)$, $ast$ und $pst$ liegen in $O(n^2)$.
\label{lem:SpeicherplatzkomplexitaetCst}
\end{lemma}

\begin{proof}[Beweis des Lemma \ref{lem:SpeicherplatzkomplexitaetCst}]
Ein Wort $t$ der Länge $n$ besitzt $n$ Suffixe. Jedes Blatt in einem Suffixbaum repräsentiert genau ein Suffix von $t$. Somit besitzt ein $cst$ für $t$ höchstens $n$ Blätter. Alle inneren Knoten eines $cst$ sind Verzweigungen. Aus dieser Beobachtung folgt, dass nicht mehr als $n$ innere Knoten im Baum existieren. Die Zahl der Kanten kann damit auf $2n$ abgeschätzt werden. Um im Worst Case tatsächlich die geforderte Speicherplatzkomplexität zu erreichen, werden die Kantenbeschriftungen durch Paare $(i, j) \in \mathbb{N} \times \mathbb{N}$ dargestellt, wobei $i$ den Anfang und $j$ das Ende der Kantenbeschriftung im Wort $t$ festlegen. Der Speicherplatzbedarf einer Kante kann dadurch auf $O(1)$ gesenkt werden. Insgesamt erhalten wir damit die gewünschte Speicherplatzkomplexität von $O(n)$.

Die Beweisidee für den $ast$ ist in Abb. \ref{fig:SpeicherplatzbedarfAst} skizziert. Der Worst Case tritt für diesen Baumtypen beispielsweise für das Wort $a^nb^n$ ein. In diesem Fall enthält der $ast$ $n + 1$ Knoten, die durch $a$-Kanten miteinander verbunden sind. Von jedem dieser Knoten zweigt ein Teilbaum mit einem Speicherplatzbedarf von $O(n)$ ab, wodurch wir insgesamt eine Speicherplatzkomplexität von $O(n^2)$ für den gesamten $ast$ erhalten.

\begin{figure}
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 30mm},
    level 2/.style = {level distance = 10mm, sibling distance = 30mm},
    level 3/.style = {level distance = 10mm, sibling distance = 30mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child[opacity = 0] {
                        node[branch]{}
                        edge from parent
                        node[right, yshift = 1mm]{}
                    }
                    child {
                        node[branch] (b5) {}
                        edge from parent
                        node[right, yshift = 1mm]{$b_1$}
                    }
                    edge from parent[solid]
                    node[left, yshift = 1mm]{$a_n$}
                }
                child {
                    node[branch] (b4) {}
                    edge from parent[solid]
                    node[right, yshift = 1mm]{$b_1$}
                }
                edge from parent[dotted]
                node[left]{}
            }
            child {
                node[branch] (b3) {}
                edge from parent
                node[right, yshift = 1mm]{$b_1$}
            }
            edge from parent
            node[left, yshift = 1mm]{$a_2$}
        }
        child {
            node[branch] (b2) {}
            edge from parent
            node[right, yshift = 1mm]{$b_1$}
        }
        edge from parent
        node[left, yshift = 1mm]{$a_1$}
    }
    child {
        node[branch] (b1) {}
        edge from parent
        node[right, yshift = 1mm]{$b_1$}
    };
    \node[subtree] at (b1.center) {$b^{n - 1}$};
    \node[subtree] at (b2.center) {$b^{n - 1}$};
    \node[subtree] at (b3.center) {$b^{n - 1}$};
    \node[subtree] at (b4.center) {$b^{n - 1}$};
    \node[subtree] at (b5.center) {$b^{n - 1}$};
    \node at (3.5, -1) {}; % Dummy Knoten
\end{tikzpicture}
\caption{Speicherplatzbedarf eines $ast$ für die Zeichenkette $a^nb^n$}
\label{fig:SpeicherplatzbedarfAst}
\end{figure}

Der Beweis für die Speicherplatzkomplexität des $pst$ erfolgt analog für das Wort $a^nb^na^nb^n$.
\end{proof}

Obwohl der Speicherplatzbedarf eines $pst$ im Worst Case in $O(n^2)$ liegt, wird in der Praxis meistens nur $O(n)$ benötigt.
Aufgrund der optimalen Speicherplatzcharakteristik des $cst$ konzentrieren wir uns im Folgenden auf diese Suffix Tree Klasse.

%////////////////////////////////////////////////////////////////////////////
\subsection{Generalized Suffix Tree}
\label{sec:GeneralizedSuffixTree}
%////////////////////////////////////////////////////////////////////////////

Bisher haben wir uns auf Suffix Trees für eine gegebene Zeichenkette beschränkt. Viele Anwendungsgebiete erfordern jedoch eine Verallgemeinerung dieses Konzepts um Suffix Trees für eine Menge von Zeichenketten konstruieren zu können. In der Literatur\footnote{Eine Definition von Generalized Suffix Trees kann beispielsweise in \cite{Gusfield1997} gefunden werden.} werden diese Bäume als Generalized Suffix Trees $GST$ bezeichnet.

\begin{definition}[Generalized Suffix Tree]
Sei $D = \{s_1, \dots, s_n\}$ eine Menge von Strings über $\Sigma$, $T = \{t_1, \dots, t_n\}$ eine Menge von Terminalsymbolen mit $T \cap \Sigma = \emptyset$. Ein $GST_D$ ist ein $\Sigma^+$-Baum, sodass für alle $i \leq n$ gilt:
\begin{gather*}
    w \in GST_D \Longleftrightarrow w \text{ ist ein } s_it_i\text{-Wort}
\end{gather*}
\label{def:GeneralizedSuffixTree}
\end{definition}

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 12mm, sibling distance = 45mm},
    level 2/.style = {level distance = 12mm, sibling distance = 25mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$gcg\$$}
        }
        child {
            edge from parent
            node[right]{$cg\#$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$\$$}
        }
        child {
            edge from parent
            node[right]{$\#$}
        }
        edge from parent
        node[left]{$cg$}
    }
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$cg\$$}
        }
        child {
            edge from parent
            node[left]{$\$$}
        }
        child {
            edge from parent
            node[right]{$\#$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\caption{$GST$ für $D = \{agcg, acg\}$ und $T = \{\$, \#\}$}
\label{fig:GSTAgcgAcg}
\end{figure}

Da die Menge der Terminalsymbole $T$ und das Alphabet $\Sigma$ disjunkt sind, kann jedes Blatt eines $GST_D$ genau einem String aus $D$ zugeordnet werden. Diese Eigenschaft spielt eine wichtige Rolle für viele Anwendungsgebiete von Generalized Suffix Trees, wie z.B. dem in Abschnitt \ref{sec:LongestCommonSubstring}.

%////////////////////////////////////////////////////////////////////////////
\section{Anwendungsgebiete}
\label{sec:Anwendungsgebiete}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\subsection{Überblick}
\label{sec:Ueberblick}
%////////////////////////////////////////////////////////////////////////////

Suffix Trees eignen sich insbesondere für Problemlösungen im Bereich der Stringverarbeitung.

\begin{table}
\centering
\begin{tabular}{l}
    \toprule
    All-pairs suffix-prefix matching      \\
    Construction of DAWGs                 \\
    Exact set matching                    \\
    Exact string matching                 \\
    k-mismatch                            \\
    Longest common substring              \\
    Matching statistics                   \\
    Maximal repeated pairs                \\
    Maximal repeats                       \\
    Supermaximal repeats                  \\
    Ziv–Lempel decomposition              \\
    ...                                   \\
    \bottomrule
\end{tabular}
\caption{Anwendungsgebiete für Suffix Trees}
\label{tab:AnwendungsgebieteFuerSuffixTrees}
\end{table}

%////////////////////////////////////////////////////////////////////////////
\subsection{Longest common substring}
\label{sec:LongestCommonSubstring}
%////////////////////////////////////////////////////////////////////////////

In diesem Abschnitt möchten wir eines der vielen Anwendungsgebiete von Suffix Trees exemplarisch vorstellen.

\begin{problem}[$k$-common substring]
Gegeben eine Menge von Strings $S = \{s_1, \dots, s_K\}$ aus $\Sigma^*$ mit $n = \sum_{i = 1}^K \abs{s_i}$. Für jedes $2 \leq k \leq K$ wird die Länge des längsten gemeinsamen Teilwortes der Strings $s_i$ mit $i \leq k$ gesucht.
\end{problem}

Die Vorstellung der Lösung des allgemeinen $k$-common substring Problem würde den Umfang dieses als motivierendes Beispiel gedachten Abschnittes sprengen. Deshalb beschränken wir uns auf den Spezialfall für $k = 2$.

\begin{problem}[Longest common substring]
Gegeben zwei Strings $s_1, s_2 \in \Sigma^*$. Gesucht wird die Länge des längsten gemeinsamen Teilworts von $s_1$ und $s_2$.
\end{problem}

Der Aufwand für das $k$-common substring Problem beträgt unter Zuhilfenahme eines Generalized Suffix Trees $O(nK)$\footnote{Mithilfe eines weiteren Vorverarbeitungsschrittes des $GST$ kann dieser Aufwand auf $O(n)$ gesenkt werden. Weitere Details können \cite{Gusfield1997} entnommen werden.}. Für den Spezialfall mit $k = 2$ erhalten wir demzufolge $O(\abs{s_1} + \abs{s_2})$.

Wir verzichten an dieser Stelle bewußt auf eine Implementierung, da diese unserer Meinung nicht zu einem besseren Verständnis des Sachverhalts beiträgt.
Während der Erklärung des Lösungsansatzes wählen wir $s_1 = gaga$ und $s_2 = agga$ um die einzelnen Schritte zu veranschaulichen.

\paragraph{Schritt 1: $\boldsymbol{GST}$ für $\boldsymbol{s_1}$ und $\boldsymbol{s_2}$ konstruieren}
Im ersten Schritt wird ein $GST_D$ für $D = \{s_1, s_2\}$ und $T = \{\$, \#\}$ konstruiert. Abb. \ref{fig:BestimmungDesLaengstesGemeinsamesTeilwortW} zeigt den zugehörigen Generalized Suffix Tree. In den folgenden Abbildungen werden Kanten eines Knoten, deren Kantenbeschriftungen nur aus Terminalsymbolen bestehen, zu einer Kante zusammengefasst. Die Kantenbeschriftung dieser neuen Kante setzt sich aus den Beschriftungen der zusammengefassten Kanten durch Kommata getrennt zusammen.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 60mm},
    level 2/.style = {level distance = 10mm, sibling distance = 30mm},
    level 3/.style = {level distance = 10mm, sibling distance = 20mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            node[branch] (w1) {}
            child {
                edge from parent
                node[left]{$a\$$}
            }
            child {
                edge from parent
                node[right, xshift = 1mm]{$ga\#$}
            }
            edge from parent
            node[left]{$g$}
        }
        child {
            edge from parent
            node[right, xshift = 1mm]{$\$, \#$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch]{}
        child {
            node[branch] (w2) {}
            child {
                edge from parent
                node[left]{$ga\$$}
            }
            child {
                edge from parent
                node[right]{$\$, \#$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            edge from parent
            node[right, xshift = 2mm]{$ga\#$}
        }
        edge from parent
        node[above]{$g$}
    };
    \node[yshift = 3mm, xshift = -7mm] at (w1.center) {$\overline{w}$} edge [dotted] (w1);
    \node[yshift = 3mm, xshift = -7mm] at (w2.center) {$\overline{w}$} edge [dotted] (w2);
\end{tikzpicture}
\caption{Bestimmung des längsten gemeinsamen Teilwort $w$}
\label{fig:BestimmungDesLaengstesGemeinsamesTeilwortW}
\end{figure}

Um die weitere Herangehensweise zu verstehen, muss man sich den Aufbau des $GST$ nochmals vergegenwärtigen. Der $GST$ enthält alle Suffixe der beiden Strings $s_1$ und $s_2$. Jedes Blatt eines $GST$ kann durch die Verwendung der Terminalsymbole genau einem String aus der Menge $D$ zugeordnet werden. Der Pfad von der Wurzel bis zu einem Knoten $\overline{w}$ im $GST$, der als Nachfahren sowohl ein Blatt von $s_1$ als auch ein Blatt von $s_2$ besitzt, repräsentiert somit ein gemeinsames Teilwort von $s_1$ und $s_2$. Demzufolge entspricht ein Knoten mit maximaler Tiefe, der diese Eigenschaft erfüllt, dem längsten gemeinsamen Teilwort von $s_1$ und $s_2$. In Abb. \ref{fig:BestimmungDesLaengstesGemeinsamesTeilwortW} sind die entsprechenden Knoten mit $\overline{w}$ gekennzeichnet.

\paragraph{Schritt 2: Zugehörigkeit bestimmen}

In diesem Schritt berechnen wir für jeden Knoten im $GST$ seine Zugehörigkeit zu den Strings $s_1$ und $s_2$, indem wir die Blätter in den Teilbäumen dieses Knoten betrachten. Dazu definieren wir eine Abbildung $f$, die jedem Knoten $\overline{v}$ im $GST_D$ einen zweidimensionalen Bitvektor $(b_1, b_2)$ zuordnet, wobei
\begin{gather*}
    b_i = \begin{cases}
        1 &\text{falls ein Teilbaum von } \overline{v} \text{ ein Blatt von } s_i \text{ besitzt} \\
        0 &\text{sonst}
    \end{cases}
\end{gather*}
Abb. \ref{ZuordnungDerBitvektoren} zeigt den $GST_D$ mit dem jeweiligen Bitvektor für jeden Knoten.
\begin{figure}[b]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 60mm},
    level 2/.style = {level distance = 10mm, sibling distance = 30mm},
    level 3/.style = {level distance = 10mm, sibling distance = 20mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch] (b1) {}
    child {
        node[branch] (b2) {}
        child {
            node[branch] (b3) {}
            child {
                node[leaf] (l1) {}
                edge from parent
                node[left]{$a\$$}
            }
            child {
                node[leaf] (l2) {}
                edge from parent
                node[right, xshift = 1mm]{$ga\#$}
            }
            edge from parent
            node[left]{$g$}
        }
        child {
            node[leaf] (l3) {}
            edge from parent
            node[right, xshift = 1mm]{$\$, \#$}
        }
        edge from parent
        node[above]{$a$}
    }
    child {
        node[branch] (b4) {}
        child {
            node[branch] (b5) {}
            child {
                node[leaf] (l4) {}
                edge from parent
                node[left]{$ga\$$}
            }
            child {
                node[leaf] (l5) {}
                edge from parent
                node[right]{$\$, \#$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[leaf] (l6) {}
            edge from parent
            node[right, xshift = 2mm]{$ga\#$}
        }
        edge from parent
        node[above]{$g$}
    };
    \node[yshift = 8mm] at (b1) {$(1, 1)$} edge [dotted] (b1);
    \node[yshift = 3mm, xshift = -10mm] at (b2) {$(1, 1)$} edge [dotted] (b2);
    \node[yshift = 3mm, xshift = -10mm] at (b3) {$(1, 1)$} edge [dotted] (b3);
    \node[yshift = 3mm, xshift = 10mm] at (b4) {$(1, 1)$} edge [dotted] (b4);
    \node[yshift = 3mm, xshift = -10mm] at (b5) {$(1, 1)$} edge [dotted] (b5);
    \node[yshift = -8mm] at (l1) {$(1, 0)$} edge [dotted] (l1);
    \node[yshift = -8mm] at (l2) {$0, 1)$} edge [dotted] (l2);
    \node[yshift = -18mm] at (l3) {$(1, 1)$} edge [dotted] (l3);
    \node[yshift = -8mm] at (l4) {$(1, 0)$} edge [dotted] (l4);
    \node[yshift = -8mm] at (l5) {$(1, 1)$} edge [dotted] (l5);
    \node[yshift = -18mm] at (l6) {$(0, 1)$} edge [dotted] (l6);
\end{tikzpicture}
\caption{Zuordnung der Bitvektoren}
\label{ZuordnungDerBitvektoren}
\end{figure}
Durch bitweise Veroderung der Bitvektoren der Kindknoten $c_1, \dots, c_l$, kann der Bitvektor des Vaterknotens $\overline{v}$ berechnet werden. Somit lässt sich $f$ wie folgt rekursiv definieren.
\begin{gather*}
    f(\overline{v}) = \begin{cases}
        (b_1, b_2)                    &\text{falls } \overline{v} \text{ ein Blatt} \\
        f(c_1) \vee \dots \vee f(c_l) &\text{sonst}
    \end{cases}
\end{gather*}
Falls $\overline{v}$ ein Blatt ist, lassen sich $b_1$ und $b_2$ direkt anhand der Terminalsymbole in den Kantenbeschriftungen bestimmen. Aufgrund der linearen Größe von $csts$ beträgt der Aufwand zur Berechnung der Funktion $f$ $O(\abs{s_1} + \abs{s_2})$, was dem Gesamtaufwand dieses Schrittes entspricht.

\paragraph{Schritt 3: Knoten mit maximaler Tiefe finden}

%////////////////////////////////////////////////////////////////////////////
\section{Suffix Tree Konstruktion}
\label{sec:SuffixTreeKonstruktion}
%////////////////////////////////////////////////////////////////////////////

In diesem Abschnitt wird ein Algorithmus dargestellt, der einen kompakten Suffixbaum für ein Wort $t$ aufbaut. Es gibt zwei prinzipiell unterschiedlichen Ansätze dafür.

Erster Ansatz ist sukzessive Einfügung der Suffixe von $t$ in einen Baum, der als leer initialisiert wird. Die Konstruktion wird erfolgen mittels Iterationen über das Wort $t$, indem Suffixe von links nach rechts (oder auch umgekehrt) jedes Mal abgelesen werden.

In dem zweiten Ansatz wird der Baum rekursiv aufgebaut, indem zuerst Kanten von der Wurzel aufgebaut werden und dann für jeden Unterbaum das Verfahren wiederholt wird.

%////////////////////////////////////////////////////////////////////////////
\subsection{WOTD-Algorithmus}
\label{sec:WOTDAlgorithmus}
%////////////////////////////////////////////////////////////////////////////

Der Algorithmus, der wir uns in dieser Arbeit anschauen, verwendet den zweiten Ansatz. Dieser Algorithmus ist als ''Write only top down suffix tree construction''\footnote{Der Algorithmus wurde von R. Giegerich und S. Kurtz entwickelt. Siehe \cite{Giegerich1995}.}, kurz geschrieben WOTD-Algorithmus, genannt worden. ''Write only'' steht für die Eigenschaft, dass die Knoten im Baum nur konstruiert werden und danach nicht mehr gelesen. ''Top down'' steht für den Art des Aufbaus: rekursive Konstruktion, beginnend an der Wurzel mit allen Suffixen. Der Algorithmus eignet sich für die funktionale Implementierung und insbesondere für die Benutzung der laziness-Eigenschaft. Aus diesen Gründen wird für die Implementierung des Algorithmus Haskell benutzt\footnote{wir haben die Implementierung von \cite{Giegerich1995} genommen und leciht bearbeitet.}.

Die Schritte des Algorithmus werden mit einem Beispiel für das Wort $t$ = $agcgacgag$ veranschaulicht. Der Algoritmus wird wie folgt ausgeführt:

\paragraph{Schritt 1: Die Konstruktion der Suffixliste.}

Es wird eine Suffixliste eines gegebenen Wortes erzeugt. Die Suffixliste für das Wort $t$ = $agcgacgag$ ist
$[agcgacgag$, $gcgacgag$, $cgacgag$, $gacgag$, $acgag$, $cgag$, $gag$, $ag$, $g]$.

\paragraph{Schritt 2: Die Gruppierung der Suffixliste.}

Die Suffixliste wird nach den Anfangsbuchstaben gruppiert, einen Knoten wird erzeugt. Die Gruppen, die für unseres Beispiel erzeugt werden:
$$
\begin{tabular}{l l l}
    \toprule
    Gruppe 1                 & Gruppe 2               & Gruppe 3                \\
    \midrule
    $\boldsymbol{a}gcgacgag$ & $\boldsymbol{c}gacgag$ & $\boldsymbol{g}cgacgag$ \\
    $\boldsymbol{a}cgag$     & $\boldsymbol{c}gag$    & $\boldsymbol{g}acgag$   \\
    $\boldsymbol{a}g$        &                        & $\boldsymbol{g}ag$      \\
    \bottomrule
\end{tabular}
$$
\paragraph{Schritt 3: Die Berechnung des gemeinsamen Präfixes für eine Gruppe.}

Für jede Gruppe aus dem Schritt 2 wird das längste gemeinsame Präfix berechnet und eine Kante mit der Beschriftung von dem Präfix erzeugt. Die Gruppen aus dem Beispiel haben folgende Präfixe:
$$
\begin{tabular}{l l l}
    \toprule
    Gruppe 1                 & Gruppe 2               & Gruppe 3                \\
    \midrule
    $\boldsymbol{a}gcgacgag$ & $\boldsymbol{cga}cgag$ & $\boldsymbol{g}cgacgag$ \\
    $\boldsymbol{a}cgag$     & $\boldsymbol{cga}g$    & $\boldsymbol{g}acgag$   \\
    $\boldsymbol{a}g$        &                        & $\boldsymbol{g}ag$      \\
                             &                        & $\boldsymbol{g}$        \\
    \midrule
    $a$                      & $cga$                  & $g$                     \\
    \bottomrule
\end{tabular}
$$
Das jeweilige Präfix wird von den Wörtern der Gruppe entfernt und eine neue Liste wird aus den Restwörter erzeugt. Falls die neue Liste leer ist, wird der Schritt 3 für die nächste Gruppe aus dem Schritt 2 wiederholt. Falls die neue Liste noch Wörter enthält, wird der Schritt 2 für diese Liste ausgeführt. Sukzessiver Aufbau von dem Suffixbaum für das Beispiel wird in Abb. \ref{fig:cstKonstruktion} gezeigt\footnote{für eine bessere Veranschaulichung wird der Aufbau mit Levels repräsentiert}.

% [h]: here, [t]: top, [b]: bottom
\begin{figure}[h]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [yshift = 0cm]
        \node[branch]{}
        child {
            node[ghostbranch] (u) {}
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 8mm] {
            node[ghostbranch] (v) {}
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[ghostbranch] (w) {}
            edge from parent
            node[above]{$g$}
        };
        \node[align = left, anchor = north, yshift = {-1mm}] at (u.center) {$gcgacgag$ \\ $cgag$ \\ $g$};
        \node[align = left, anchor = north, yshift = {-1mm}] at (v.center) {$cgag$ \\ $g$};
        \node[align = left, anchor = north, yshift = {-1mm}] at (w.center) {$cgacgag$ \\ $acgag$ \\ $ag$};
    }
    { [yshift = -3cm]
        \node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 16mm] {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent
                    node[left]{$cgag$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
    }
    { [yshift = -6.5cm]
        \node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 16mm] {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent
                    node[left]{$cgag$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
    }
\end{tikzpicture}
\caption{cst-Konstruktion für $t$ = $agcgacgag$}
\label{fig:cstKonstruktion}
\end{figure}

%////////////////////////////////////////////////////////////////////////////
\subsection{Implementierung in Haskell}
\label{sec:ImplementierungInHaskell}
%////////////////////////////////////////////////////////////////////////////

Zuerst werden benötige Datentypen im Listing \ref{lst:typdefinitionen} beschrieben. Ein Baum ist entweder ein Blatt oder eine Verzweigung. Eine Verzweigung ist eine Liste von Tupeln, wobei erstes Element vom Tupel eine Kante (also, eine Kantenbeschriftung) ist, und zweites Element ist der Unterbaum, der von der Kante ausgeht. $alf$ ist Typparameter vom Alphabet, $Label\:alf$ ist ein Liste von Elementen des Alphabets.
Typ der EdgeFunktion bedeutet, dass man eine Liste von Wörter nimmt und auf ein Tupel abbildet, wobei erstes Element vom Tupel das längste gemeinsame Präfix der Wörter ist und zweites Element eine Liste von Wörter, von denen das längste gemeinsame Präfix entfernt wurde.

\begin{lstlisting}[
    caption = Typdefinitionen,
    label = lst:typdefinitionen,
    captionpos = b,
    float = hb
    ]
-- | Darstellung von Suffix Trees
data STree alf = Leaf | Branch [(Label alf, STree alf)] deriving Eq

-- | Darstellung von Beschriftungen
type Label alf = [alf]

-- | Darstellung vom Kantenaufbau
type EdgeFunction alf = [[alf]] -> ([alf], [[alf]])
\end{lstlisting}

Im Folgenden besprechen wir Funktionen, die einzelne Schritte des Algorithmus erledigen. Die Implementierung der Funktionen wird in Listing \ref{lst:AlgorithmusZurSuffixTreeKonstruktion} gezeigt.

\begin{lstlisting}[
    caption = Algorithmus zur Suffix Tree Konstruktion,
    label = lst:AlgorithmusZurSuffixTreeKonstruktion,
    captionpos = b,
    float = htb
    ]
-- | Liefert eine Liste aller Suffixe eines gegebenen Wortes
suffixes :: [alf] -> [[alf]]
suffixes []       = []
suffixes aw@(_:w) = aw:suffixes w

-- | Liefert alle Woerter mit Anfangsbuchstaben a
select :: (Eq alf) => [[alf]] -> alf -> [[alf]]
select ss a = [c:u | c:u <- ss, a == c]

-- | Funktion zur Kantenerzeugung
edge :: (Eq alf) => EdgeFunction alf
edge [s] = ([s], [[]])
edge awss@((a:_):ss) | all (\c:_ -> a == c) ss = (a:cp, rss)
                     | otherwise               = ([], awss)
                     where (cp, rss) = edge ([t | _:t <- awss, length t > 0])

-- | Konstruktion des Suffix Trees
lazy_cst ::(Eq alf) => (EdgeFunction alf) -> [alf] -> [alf] -> STree alf
lazy_cst edge alpha t = sTr (suffixes t)
    where
    sTr [[]] = Leaf
    sTr ss   = Branch[(cp,sTr rss) | a <- alpha,
                                     let gs = select ss a,
                                     length gs > 0,
                                     let (cp,rss) = edge gs]
\end{lstlisting}

Erste Funktion ist $suffixes$, die eine Suffixliste von einem gegebenen Wort zurückliefert.

Auswahl einer Gruppe, die mit einer Buchstabe anfängt, wird mit der Funktion $select$ erledigt. Die Buchstabe wird an dem Parameter $a$ gebunden.

Die nächste Funktion $edge$ bestimmt das längste gemeinsame Präfix für eine Gruppe der Wörter. Die Gruppe wird als Eingabeliste übergeben. Zuerst wird geprüft, ob alle Wörter mit der gleichen Buchstabe anfangen. Falls es der Fall ist, dann wird die Buchstabe an $cp$ angehängt und eine neue Liste ohne das erste Buchstabe erzeugt. Falls ein Wort sich endet, dann wird es weggelassen. Die Funktion terminiert falls es nur ein Wort in der Gruppe bleibt oder wenn nicht alle Restwörter in der Gruppe mit der gleichen Buchstabe anfangen. Die Funktion gibt ein Tupel zurück, wobei erstes Element von dem Tupel das längste gemeinsame Präfix der Wörter in der Eingabeliste ist und zweites Element eine Liste von restlichen Wörter, von denen das längste gemeinsame Präfix entfernt wurde.

Die letzte Funktion $lazy\_cst$ setzt die oben besprochene Funktionen zusammen und erzeugt den kompletten Baum. Als Eingabe wird die Funktion $edge$, einen Alphabet des gegebenen Wort in der Form einer Liste von Buchstaben und ein Wort t, für das Siffixbaum aufgebaut werden soll, gegeben. Die Suffixliste von $t$ wird an einer Hilfsfunktion $sTr$ geliefert, die den Baum wie folgt rekursiv aufbaut:

    - Wenn die Suffixliste leer ist, dann wird ein Blatt erstellt.

    - Wenn die Suffixliste nicht leer ist, dann wird eine Verzweigung erstellt.

Eine Verzweigung besteht aus $n \ge 2$ Tupeln, die in der esten Komponente das längste gemeinsame Präfix von jeder Gruppe als Kantenbeschriftung und einen entsprechenden Unterbaum in der zweiten Komponente enthalten. Der entsprechende Unterbaum wird rekursiv erzeugt.

Die Kantenliste wird aufgebaut, indem:
\begin{enumerate}
    \item Jede Buchstabe des Alphabets an der Variable $a$ gebunden wird.
    \item Die entsprechende Liste durch den Aufruf der Funktion $select$ an der Variable $gs$ gebunden wird.
    \item Falls die Gruppe nicht leer ist, wird durch den Aufruf von $edge$ das gemeinsame Präfix und die Liste von Restwörter berechnet.
\end{enumerate}

%////////////////////////////////////////////////////////////////////////////
\subsection{Laufzeitanalyse}
\label{sec:Laufzeitanalyse}
%////////////////////////////////////////////////////////////////////////////

Um die Laufzeit von dem gesamten Algorithmus zu betrachten, wird zuerst die Kostenabschätzung von der Funktion $edge$ bestimmt, weil diese Funktion die höchste Laufzeitkomplexität besitzt.

Die Kostenfunktion für $edge$ ist von zwei Parameter abhängig: die Länge der Wörterliste und die Länge des gemeinsamen Präfix dieser Wörter. Die Funktion wird so oft rekursiv aufgerufen wie die Länge des gemeinsamen Präfix von der gegebenen Wörterliste ist. In jedem Aufruf von $edge$ werden zwei andere Funktionen aufgerufen, deren Laufzeit von der Länge der Eingabeliste linear abhängig ist. Eine der Funktionen ist lambda-Ausdruck, wir haben zur Vereinfachung sie als $isEqual$ bei der Laufzeitanalyse bezeichnet. Zweite Funktion ist als List-comprehension gegeben, sie wird als $newList$ bezeichnet.

Die Kosten der Funktion $edge$ setzen sich zusammen aus den Kosten der Funktion $isEqual$ für $n - 1$, den Kosten der Funktion $newList$ für $n$ und den Kosten des rekursiven Aufrufs von $edge$ für $n - 1$ und $\abs{cp} - 1$.

Insgesamt:
\begin{align*}
    T(n,\abs{cp}) &= isEqual(n - 1) + newList(n) + T(n-1,\abs{cp}-1) \\
                  &= \sum_{i = 1}^{\abs{cp}}{isEqual(n-1)} + \sum_{i = 1}^{\abs{cp}}{newList(n)}\\
                  &= \abs{cp} (n - 1) + \abs{cp} n \in O(\abs{cp} \cdot n)
\end{align*}

Weiter wird das worst-case des WOTD-Algoritmus bestimmt. Dieses produziert z.B. das Wort $a^n$, indem es als der Parameter $t$ an der Funktion $lazy\_cst$ gegeben wird. Zuerst wird $sTr$ mit $ss = [a^n,\:a^{n-1}, \dots ,\:a]$ aufgerufen, dann wird dem Parameter $gs$ komplette Liste $ss$ zugewiesen und die Funktion $edge$ mit dem Parameter $gs$ aufgerufen. Die Funktion $edge$ liefert das Ergebnis $(cp,rss) = (a^n, [[\:]])$. Weiter wird $sTr$ mit mit dem Parameter $rss = [[\:]]$ aufgerufen und damit terminiert die Funktion $lazy\_cst$. Weil $|cp| = n$, ist die Laufzeit von $edge$ und von dem gesamten Algorithmus $O(n^2)$.

%////////////////////////////////////////////////////////////////////////////
\section{Teilwortsuche}
\label{sec:Teilwortsuche}
%////////////////////////////////////////////////////////////////////////////

Zum Abschluss des Kapitels möchten wir zeigen, dass mit dem erzeugten Suffixbaum man nicht nur Suffixe effezient suchen kann, sondern auch Teilwörter von einem gegebenen Wort. Dafür definieren wir eine Hilfsfunkktion $commonPrefix$, die ähnlich wie die $edge$-Funktion arbeitet. Die Implementierung wird in Listing \ref{lst:SucheImSuffixTree} gezeigt. Die Funktion bestimmt das längste gemeinsame Präfix von zwei Wörter und liefert ein Tripel $(w1',\: w2',\: cp)$ zurück, wobei $cp$ das längste gemeinsame Präfix ist, $w1'$ und $w2'$ Ergebnisse der Entfernung $cp$ von $w1$ bzw. $w2$ sind.

Die tatsächliche Teilwortsuche haben wir mit der Funktion $search$ gelöst (siehe Listing \ref{lst:SucheImSuffixTree}). Die Eingabe ist ein Teilwort und ein Baum, in dem das Teilwort gesucht wird. Die Funktion erledigt die Suche wie folgt:

    - Falls der Baum leer ist, dann ist die Suche nicht möglich.

    - Falls der Baum eine Verzweigung ist, dann wird eine Hilfsfunktion $g$ mit dem gesuchten Wort und der Liste von Kanten aufgerufen.

Fallunterscheidung der Funktion $g$:
\begin{enumerate}
    \item Wenn die Liste von Kanten leer ist, dann ist das Wort in dem Baum nicht enthalten.
    \item Im anderen Fall wird die passende Kante gesucht, indem das gemeinsame Präfix des gesuchten Wortes und jeweilige Kante berechnet werden. Das wird mit der Funktion $commonPrefix$ gemacht. Wenn das gesuchte Wort und jeweilige Kante kein gemeinsames Präfix haben, dann muss die nächste Kante angeschaut werden $\rightarrow$ der Fall $falsche$ $Kante$.
    \item Wenn es keine Kanten mehr gibt, dann ist das gesuchte Teilwort nicht in dem Baum enthalten $\rightarrow$ der Fall $g$ $ss$ $[\:]$ $=$ $False$.
    \item Wenn das gesuchte Teilwort und die Kante das gemeinsame Präfix haben, dann müssen drei Fälle betrachtet werden:
    \begin{enumerate}
        \item Die Kante ist ein Teil von dem gesuchten Teilwort $\rightarrow$ der Fall $richtige$ $Kante$.
        \item Das gesuchte Teilwort ist ein Teil von der Kantenbeschriftung $\rightarrow$ der Fall $ss$ $ist$ $leer$.
        \item Das gemeinsame Präfix ist nicht leer, aber enthält weder komplette Kantenbeschriftung, noch das komplette gesuchte Wort $\rightarrow$ der Fall $cp\:!=\:[\:]\mid l \mid ss$.
    \end{enumerate}
\end{enumerate}

\begin{lstlisting}[
    caption = Suche im Suffix Tree,
    label = lst:SucheImSuffixTree,
    captionpos = b,
    float = htb
    ]
commonPrefix :: (Eq alph) => Word alph -> Word alph -> (Word alph, Word alph, Word alph)
commonPrefix w1 w2 = g w1 w2 []
    where g (x:xs) (y:ys) cp | (x == y) = g xs ys (x:cp)
          g w1 w2 cp  = (w1, w2, reverse cp)

search :: (Eq alph) => Word alph -> STree alph -> Bool
search ss Leaf        = False
search ss (Branch es) =  g ss es
    where
    g ss [] = False
    g ss (((l, st):es)) =
        case commonPrefix ss l of
         ([], _, _)   -> True          -- ss ist leer
         (_, _, [])   -> g ss es       -- falsche Kante
         (ss', [], _) -> search ss' st -- richtige Kante
         _            -> False         -- cp != []|l|ss

--| Beispielsuche
let alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
    word = "agcgacgag"
in  search "cgac" (lazy_cst edge alphabet word)
\end{lstlisting}

Dank der laziness-Eigenschaft, werden nur die Kanten von dem Suffixbaum während der Suche konstruiert, die für die Suche relevant sind, und der Rest von dem Suffixbaum wird nicht angeschaut. Diese Eigenschaft zeigen wir an einem Beispiel.

Sei ein Teilwort $cgac$ in dem Wort $agcgacgag$ gesucht. Wir definieren ein passendes Alphabet und übergeben es mit dem Teilwort und dem Wort an der Funktion $search$ (siehe Listing \ref{lst:SucheImSuffixTree}). Die Abb. \ref{fig:teilwortuche} zeigt das Teil des Suffixbaums, das während der Suche konstruiert wird.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 12mm, sibling distance = 50mm},
    level 2/.style = {level distance = 12mm, sibling distance = 35mm},
    level 3/.style = {level distance = 12mm, sibling distance = 20mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child[child anchor = north] {
        node[subtree] (a) {}
        edge from parent
        node[above]{$a$}
    }
    child[child anchor = north, level distance = 16mm] {
        node[branch]{}
        child {
            node[subtree]{}
            edge from parent
            node[left]{$\boldsymbol{c}gag$}
        }
        child[child anchor = north] {
            edge from parent[dotted]
        }
        edge from parent
        node[left]{$\boldsymbol{cga}$}
    }
    child[child anchor = north] {
        edge from parent[dotted]
    };
\end{tikzpicture}
\caption{Teilwortsuche im Suffix Tree}
\label{fig:teilwortuche}
\end{figure}

%////////////////////////////////////////////////////////////////////////////
\chapter{Suffix Array}
\label{sec:SuffixArray}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\section{Motivation}
\label{sec:Motivation}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\section{Terminologie}
\label{sec:Terminologie}
%////////////////////////////////////////////////////////////////////////////
Im Folgenden benutzen wir die Notation, die in \cite{Karkkainen2006} eingeführt worden ist.

Intervalle werden mit $[i,j] = \{ i, \dots, j\}$ und $[i,j) = [i,j-1]$ bezeichnet. Ein Wort über ein Alphabet wird als $T = T[0,n) = t_0 t_1 \dots t_{n-1}$ dargestellt, wobei $t_i$ Buchstaben des Alphabets sind. Es wird die Konvention verwendet, dass $t_j = 0$ für $j \ge n$ ist. Für ein $i \in [0,n]$ wird ein Suffix $S_i = T[i,n) = t_i t_{i+1} \dots t_n$ definiert. Für eine Menge $C \subseteq [0,n]$ wird eine Suffixmenge $S_C = \{ S_i \mid i \in C\}$ eingeführt.

\begin{definition}[Suffix Array]
Ein Suffix Array $SA[0,n)$ für ein gegebenes Wort $T[0,n)$ ist eine Permutation von $[0,n)$ mit $S_{SA[0]} \prec S_{SA[1]} \prec \dots \prec S_{SA[n-1]}$, wobei $\prec$ die lexikographische Ordnung auf Zeichenketten bezeichnet.
\end{definition}

%////////////////////////////////////////////////////////////////////////////
\section{DC3-Algorithmus}
\label{sec:DC3Algorithmus}
%////////////////////////////////////////////////////////////////////////////

Der Algorithmus, den wir uns zu der Konstruktion des Suffixarrays anschauen, ist DC3\footnote{Der Algorithmus ist in \cite{Karkkainen2006} vorgestellt worden ist.} (Difference Cover modulo 3) genannt worden. Die Schritte des Algorithmus werden mit einem Beispiel veranschaulicht. Die Struktur des DC3-Algorithmus haben wir in Abb. \ref{fig:strukturDC3} gezeigt.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 20mm, sibling distance = 45mm},
    level 2/.style = {level distance = 20mm, sibling distance = 45mm},
    level 3/.style = {level distance = 20mm, sibling distance = 45mm},
    edge from parent/.style = {->, draw}
    ]
    \node (n1) {
        \begin{tabular}{c}
            Schritt 1: Divide yabbadabbado \\
            \midrule
            \color{black}Schritt 4: Merge \\
        \end{tabular}}
    child {
        node {Schritt 3: Sort}
        edge from parent[]
        node[left, xshift = -2mm]{i mod 3 = 0}
        node[right, xshift = 2mm]{$\sfrac{1}{3}$}
    }
    child {
        node {Schritt 2: Sort recursive}
        child {
            edge from parent[dotted]
        }
        child {
            edge from parent[dotted]
        }
        edge from parent[]
        node[right, xshift = 2mm]{i mod 3 = 1 o. 2}
        node[left, xshift = -2mm]{$\sfrac{2}{3}$}
    };
\end{tikzpicture}
\caption{Struktur des DC3-Algorithmus}
\label{fig:strukturDC3}
\end{figure}

Als Eingabe haben wir das Wort
$$
\begin{tabular}{l|c c c c c c c c c c c c}
    \toprule
    i    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
    \midrule
    T[0,n) & y & a & b & b & a & d & a & b & b & a & d  & o  \\
    \bottomrule
\end{tabular}
$$

\paragraph{Schritt 1: Die Konstruktion der Sample-Suffixe.}

Für $k = 0,1,2$ werden Mengen wie folgt definiert:
$$
B_k = \{ i \in [0,n] \mid i \bmod{3} = k\}
$$

Sei $C = B_1 \cup B_2$ die Menge der Sample-Positionen und $S_C$ ist die Menge der Sample-Suffixe. In unserem Beispiel:
$$
B_1 = \{1,4,7,10\},\;B_2 = \{2,5,8,11\},\;C = \{1,4,7,10,2,5,8,11\}
$$

\paragraph{Schritt 2: Das Sortieren der Sample-Suffixe.}

Für k = 1,2 werden folgende Zeichenketten konstruiert:
$$
R_k = [t_k t_{k+1} t_{k+2}][t_{k+3} t_{k+4} t_{k+5}] \dots [t_{max\:B_k} t_{max\:B_k + 1} t_{max\:B_k + 2}]
$$
wobei jedes Tripel der Form $[t_i t_{i+1} t_{i+2}]$ ein Sample ist. Sei $R = R_1 \odot R_2$ die Konkatenation von $R_1$ und $R_2$. Die Samples von $R$ korrespondieren mit der Menge $S_C$ von Sample-Suffixen, so dass $[t_i t_{i+1} t_{i+2}] \dots$ korrespondiert mit $S_i$. In unserem Beispiel:
$$
R_1 = [abb][ada]][bba][do0],\;R_2 = [bba][dab][bad][o00] 
$$
werden konkateniert zu
$$
R = [abb][ada]][bba][do0][bba][dab][bad][o00]
$$
Die Samples von $R$ werden mit Radixsort sortiert und es wird jedem Sample sein Rang zugewiesen:
$$
\centering
\begin{tikzpicture}
    [
        matrix of nodes/.style = {
        execute at begin cell = \node\bgroup,
        execute at end cell = \egroup;%
    }]
    \matrix[ampersand replacement = \&, column sep = -2mm, matrix of nodes]
    {
        $1$ \&
        $2$\&
        $3$ \&
        $4$ \&
        $5$ \&
        $6$ \&
        $7$ \\
        \color{black}$[abb]$ \&
        \color{black}$[ada]$ \&
        \color{black}$[bad]$ \&
        \color{black}$[bba]$ \&
        \color{black}$[dab]$ \&
        \color{black}$[do0]$ \&
        \color{black}$[o00]$ \\
    };
\end{tikzpicture}
$$
Dann wird eine neue Zeichenkette $R'$ erzeugt, indem jedes Sample in $R$ durch sein Rang ersetzt wird:
$$
R = [abb][ada]][bba][do0][bba][dab][bad][o00]
$$
wird umgewandelt zu
$$
R' = 12464537
$$
Wenn jedes Zeichen in $R'$ eindeutig ist, dann sind die Sample-Suffixe sortiert und $R'$ ist das Suffixarray für $S_C$. Anderfalls wird der Algorithmus rekursiv für die Zeichenkette $R'$ verwendet. In unserem Beispiel findet es ein rekursiver Aufruf von DC3 mit $R' = 12464537$ statt, der in Abb. \ref{fig:sortRecursive} veranschaulicht wird.

Der rekursive Aufruf liefert das Suffixarray für $R'$. In unserem Beispiel ist
$$
SA_{R'} = (0,1,6,4,2,5,3,7)
$$
Wenn die Sample-Suffixe sortiert sind, es wird jedem Sample-Suffix sein Rang zugewiesen. Für $i \in C$ bezeichnet $rank(S_i)$ den Rang von $S_i$ in der Menge $S_C$. Für $i \in B_0$ ist $rank(S_i)$ noch undefiniert. In unserem Beispiel:
$$
\begin{tabular}{l|c c c c c c c c c c c c}
    \toprule
    $i$    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
    \midrule
    $T[0,n)$ & y & a & b & b & a & d & a & b & b & a & d  & o  \\
    \midrule
    $rank(S_i)$ & ? & 1 & 4 & ? & 2 & 6 & ? & 5 & 3 & ? & 7  & 8 \\
    \bottomrule
\end{tabular}
$$

\paragraph{Schritt 3: Das Sortieren der Nicht-Sample-Suffixe.}

Das sind die Suffixe aus der Menge $S_{B_0} = \{S_i \mid i \in B_0\}$. Jedes Suffix $S_i \in S_{B_0}$ wird mit dem Tupel $(t_i,rank(S_{i+1}))$ repräsentiert. Die Tupel werden mit Radixsort sortiert, indem:
$$
S_i \le S_j \; \leftrightarrow \; (t_i,rank(S_{i+1})) \le (t_j,rank(S_{j+1}))
$$
Im Beispiel:
$$
S_6 < S_9 < S_3 < S_0 \mbox{, weil }(a,5) < (a,7) < (b,2) < (y,1)
$$

\paragraph{Schritt 4: Merge.}

Zu diesem Schritt haben wir zwei sortierte Mengen, die jetzt vereinigt werden müssen. Um die Sample-Suffixe $S_i \in S_C$ mit Nicht-Sample-Suffixe $S_j \in S_{B_0}$ zu vergleichen, wird folgende Ordnung benutzt:

    - Falls $i \in B_1$, dann $S_i \le S_j \leftrightarrow (t_i,rank(S_{i+1})) \le (t_j,rank(S_{j+1}))$. Z.B. $S_1 = abbadabbado$ und $S_6 = abbado$: $S_1 \rightarrow (a,4)$ und $S_6 \rightarrow (a,5)$, $(a,4) < (a,5) \rightarrow S_1 < S_6$

    - Falls $i \in B_2$, dann $S_i \le S_j \leftrightarrow (t_i,t_{i+1},rank(S_{i+2})) \le (t_j,t_{j+1},rank(S_{j+2}))$. Z.B. $S_3 = badabbado$ und $S_8 = bado$: $S_3 \rightarrow (b,a,6)$ und $S_8 \rightarrow (b,a,7)$, $(b,a,6) < (b,a,7) \rightarrow S_3 < S_8$

Nach dem der Rang von jedem Suffix bestimmt ist und die zwei Mengen vereinigt worden sind, kann man das gesuchte Suffixarray ablesen. Die Abb. \ref{fig:Suffixarray} veranschaulicht der Schritt für das Beispiel.

\begin{figure}[htb]
\centering
\begin{tikzpicture}
    [
        matrix of nodes/.style = {
        execute at begin cell = \node\bgroup,
        execute at end cell = \egroup;%
        }
    ]
    \matrix[ampersand replacement = \&, column sep = -2mm, matrix of nodes] (m) {
        \color{black}[ \& \color{aquamarine}a\color{gray}bb\color{black} \& ] \&
        \color{black}[ \& \color{aquamarine}a\color{gray}da\color{black}\color{black} \& ] \&
        \color{black}[ \& \color{aquamarine}b\color{gray}ba\color{black} \& ] \&
        \color{black}[ \& \color{aquamarine}d\color{gray}o0\color{black} \& ] \&
        \color{black}[ \& \color{blue}b\color{gray}ba\color{black} \& ] \&
        \color{black}[ \& \color{blue}d\color{gray}ab\color{black} \& ] \&
        \color{black}[ \& \color{blue}b\color{gray}ad\color{black} \& ] \&
        \color{black}[ \& \color{blue}o\color{gray}00\color{black} \& ] \& \\
        \color{black}[ \& 1 \& ] \&
        \color{black}[ \& 2 \& ] \&
        \color{black}[ \& 4 \& ] \&
        \color{black}[ \& 6 \& ] \&
        \color{black}[ \& 4 \& ] \&
        \color{black}[ \& 5 \& ] \&
        \color{black}[ \& 3 \& ] \&
        \color{black}[ \& 7 \& ] \& \\
                       \&   \&   \&
                       \&   \&   \&
        \color{black}[ \& 4 \&   \&
                       \& 6 \&   \&
                       \& 4 \& ] \&
                       \&   \&   \&
                       \&   \&   \&
                       \&   \&   \& \\
                       \&   \&   \&
                       \&   \&   \&
                       \&   \&   \&
                       \&   \&   \&
        \color{black}[ \& 4 \&   \&
                       \& 5 \&   \&
                       \& 3 \& ] \&
                       \&   \&   \& \\
    };
    \node[left = 2cm, above = 2cm] (n1) at (m) {\color{gray}y\color{aquamarine}a\color{gray}bb\color{aquamarine}a\color{gray}da\color{aquamarine}b\color{gray}ba\color{aquamarine}d\color{gray}o};
    \node[right = 2cm, above = 2cm] (n2) at (m) {\color{gray}ya\color{blue}b\color{gray}ba\color{blue}d\color{gray}ab\color{blue}b\color{gray}ad\color{blue}o};
    \fill[aquamarine!30] (-1.8, 2.1) -- (-0.75, 2.1) -- (0, 1.25) -- (-1.8, 1.25) -- cycle;
    \fill[blue!30] (1.25, 2.1) -- (3.15, 2.1) -- (3.9, 1.25) -- (0.15, 1.25) -- cycle;
\end{tikzpicture}
\caption{Sort recursive}
\label{fig:sortRecursive}
\end{figure}

\begin{figure}[htb]
\centering
\begin{tikzpicture}
    \node (n1) {
        \begin{tabular}{l|c c c c c c c c c c c c}
            \toprule
            $i$    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
            \midrule
            $T[0,n)$ & y  & a & b & b & a & d & a & b & b & a & d  & o  \\
            \midrule
            $rank(S_i)$ & 12 & 1 & 7 & 5 & 3 & 9 & 2 & 8 & 6 & 4 & 10 & 11 \\
            \bottomrule
        \end{tabular}
    };
    \node[below = 2cm] (n2) {
        \begin{tabular}{l l|l l}
            \toprule
            $S_1$       & $a b b a d a b b a d o$ & $S_2$    & $b b a d a b b a d o$     \\
            $S_6$       & $a b b a d o$           & $S_7$    & $b b a d o$               \\
            $S_4$       & $a d a b b a d o$       & $S_5$    & $d a b b a d o$           \\
            $S_9$       & $a d o$                 & $S_{10}$ & $d o$                     \\
            $S_3$       & $b a d a b b a d o$     & $S_{11}$ & $o$                       \\
            $S_8$       & $b a d o$               & $S_0$    & $y a b b a d a b b a d o$ \\
            \bottomrule
        \end{tabular}
    };
    \path[->] (n1) edge (n2);
\end{tikzpicture}
\caption{Suffixarray}
\label{fig:Suffixarray}
\end{figure}

\paragraph{Eigenschaften von DC3.}

Laufzeit des Algorithmus ist $O(n)$ im Worst case, das ist der schnellste Algorithmus in der Klasse $O(n)$ für den Aufbau des Suffixarrays. Die schnellere Algorithmen, wie z.B. qsufsort \cite{Larsson2007}, haben einen schlechteren Worst case $O(n \log n)$.

%////////////////////////////////////////////////////////////////////////////
% Literaturverzeichnis
%////////////////////////////////////////////////////////////////////////////

\bibliography{refs}
\nocite{*}

\end{document}
%////////////////////////////////////////////////////////////////////////////
% Ausarbeitung "Suffix Trees und Suffix Arrays"
%////////////////////////////////////////////////////////////////////////////

% Autoren   : Simon Kaltenbacher, Evgeny Novoseltsev
% Semester  : WS 11/12
% Vorlesung : Effiziente funktionale Datenstrukturen
% Betreuer  : Prof. Martin Hofmann, PhD

%////////////////////////////////////////////////////////////////////////////

\documentclass[12pt]{report}

%////////////////////////////////////////////////////////////////////////////
% Import
%////////////////////////////////////////////////////////////////////////////

\usepackage{graphicx}    % needed for including graphics e.g. EPS, PS
\usepackage[ngerman]{babel}
\usepackage{textcomp}
% Umlaute in Ausgabedokument anzeigen
\usepackage[T1]{fontenc}
% Kodierung festlegen
%\usepackage{ucs}
\usepackage[utf8]{inputenc}
% Mathematische Notationen
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathtools, xfrac}
% Code von Programmiersprachen erkennen
% \usepackage{courier}
\usepackage{inconsolata}
\usepackage{listings, xcolor}
% Bäume zeichnen
\usepackage{tikz}
\usepackage{caption}
% Tabellen
\usepackage{booktabs}
\usepackage{tabularx}
% Überschriften in der Kopfzeile
\usepackage{fancyhdr}
% Literaturverzeichnis
\usepackage[numbers, square]{natbib}

%////////////////////////////////////////////////////////////////////////////
% Konfiguration
%////////////////////////////////////////////////////////////////////////////

%--Article Konfiguration-----------------------------------------------------

\topmargin -1.5cm        % read Lamport p.163
\oddsidemargin -0.04cm   % read Lamport p.163
\evensidemargin -0.04cm  % same as oddsidemargin but for left-hand pages
\textwidth 16.59cm
\textheight 21.94cm
%\pagestyle{empty}       % Uncomment if don't want page numbers
\parskip 7.2pt           % sets spacing between paragraphs
%\renewcommand{\baselinestretch}{1.5} 	% Uncomment for 1.5 spacing between lines
\parindent 0pt		  	 % sets leading space for paragraphs

%--Fancyheadings-Konfiguration-----------------------------------------------

\pagestyle{fancy}

%--Farben--------------------------------------------------------------------

\definecolor{verylightgray}{RGB}{230, 230, 230}
\definecolor{rubinered}{RGB}{243, 0, 125}
\definecolor{aquamarine}{RGB}{0, 193, 223}

%--listings-Konfiguration----------------------------------------------------

\definecolor{verylightgray}{RGB}{230, 230, 230}
\lstloadlanguages{Haskell}
\lstset {
    language = Haskell,
    tabsize = 4,
    showstringspaces = false,
    breaklines = true,
    basicstyle = \ttfamily\fontsize{11}{11}\selectfont,
    keywordstyle = \color{blue},
    commentstyle = \color{darkgray},
    framesep = 2mm,
    rulecolor = \color{black},
    frame = lines,
    extendedchars = true,
    framextopmargin = 5pt,
    xleftmargin = 5pt,
    framexleftmargin = 5pt,
    framexrightmargin = 5pt,
    framexbottommargin = 5pt,
}

%--TikZ Konfiguration--------------------------------------------------------

\usetikzlibrary{trees, calc, shapes, scopes}

%--Styledefinitionen für Suffix Trees----------------------------------------

\tikzstyle{branch} = [
    shape = circle,
    minimum size = 1mm,
    inner sep = 0mm,
    outer sep = 0.5mm,
    fill
]
\tikzstyle{ghostbranch} = [
    shape = circle,
    draw,
    minimum size = 1mm,
    inner sep = 0mm,
    outer sep = 0.5mm
]
\tikzstyle{leaf} = [
    inner sep = 0mm,
    outer sep = 0mm
]
\tikzstyle{subtree} = [
    isosceles triangle,
    dotted,
    draw,
    shape border rotate = 90,
    isosceles triangle stretches = true,
    minimum height = 10mm,
    minimum width = 10mm,
    inner sep = 0,
    anchor = north,
    font = \tiny
]

%--Literaturverzeichnis------------------------------------------------------

% Literaturverzeichnis Stil
\bibliographystyle{alpha}

%--Benutzerdefinierte Makros-------------------------------------------------

% Umgebung Bemerkung
\newtheorem{remark}{Bemerkung}
\newtheorem{definition}{Definition}

\newcommand{\coloneqq}{\mathrel{\mathop:}=}

\newcommand{\abs}[1]{\left|#1\right|}

%////////////////////////////////////////////////////////////////////////////
% Dokumenteigenschaften
%////////////////////////////////////////////////////////////////////////////

% Titel
\title{Suffix Trees und Suffix Arrays}

% Autoren
\author{Simon Kaltenbacher, Evgeny Novoseltsev}

% Erstellungsdatum
\date{\today}

%////////////////////////////////////////////////////////////////////////////
% Dokument
%////////////////////////////////////////////////////////////////////////////

\begin{document}

%--Seite: Titel--------------------------------------------------------------
\maketitle

%--Seite: Inhaltsverzeichnis-------------------------------------------------
\tableofcontents

\begin{abstract}
TODO: Einleitung
\end{abstract}

%////////////////////////////////////////////////////////////////////////////
\chapter{Suffix Tree}
\label{chap:SuffixTree}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\section{Terminologie}
\label{sec:SuffixTreeTerminologie}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\subsection{Grundlagen}
\label{sec:Grundlagen}
%////////////////////////////////////////////////////////////////////////////

Zunächst möchten wir auf die grundlegende Notation eingehen, die in dieser Abhandlung Verwendung findet.

Sei $\Sigma$ ein endliches Alphabet. Das leere Wort bezeichnen wir mit $\epsilon$. Wie gewohnt bezeichnet $\Sigma^*$ die Kleen'sche Hülle von $\Sigma$ und $\Sigma^+ \coloneqq \Sigma^* \setminus \{\epsilon\}$. Zur besseren Übersichtlichkeit verwenden wir im Folgenden $a - g$ auschließlich für Buchstaben aus $\Sigma$ und $t - z$ für Wörter über $\Sigma^*$. Mit $uv$ bezeichnen wir die Konkatenation der Wörter $u$ und $v$.

\begin{definition}[Präfix, Suffix, $t$-Wort]
Sei $t = uvw$ mit $u, v, w \in \Sigma^*$. Dann ist $u$ ein Präfix und $w$ ein Suffix von $t$. $v$ wird als $t$-Wort bezeichnet.
\end{definition}

\begin{definition}[$\Sigma^+$-Baum]
\label{def:SigmaPlusBaum}
Ein $\Sigma^+$-Baum ist ein Baum, dessen Kanten mit Wörtern aus $\Sigma^+$ beschriftet sind. Die Kanten eines $\Sigma^+$-Baums erfüllen folgendes Eindeutigkeitskriterium: Für alle Kanten $k \xrightarrow{aw} k'$ und $k \xrightarrow{bv} k''$ folgt $a = b$.
\end{definition}

Abb. \ref{fig:SigmaPlusTree} zeigt einen $\Sigma^+$-Baum für das Alphabet $\Sigma = \{a, \dots, g \}$. Um im weiteren Verlauf besser über diese Art von Bäumen und ihre Bestandteile sprechen zu können, benötigen wir noch eine Reihe von nützlichen Definitionen.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 35mm},
    level 2/.style = {level distance = 10mm, sibling distance = 25mm},
    level 3/.style = {level distance = 10mm, sibling distance = 20mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$ad$}
        }
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[right, yshift = 0.5mm]{$gd$}
        }
        edge from parent
        node[above]{$ad$}
    }
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$a$}
        }
        edge from parent
        node[left]{$cg$}
    }
    child {
        node[branch]{}
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[left, yshift = 0.5mm]{$ga$}
        }
        child[child anchor = north] {
            node[subtree]{}
            edge from parent
            node[right, yshift = 0.5mm]{$ad$}
        }
        edge from parent
        node[above]{$gac$}
    };
\end{tikzpicture}
\medskip
\caption{$\Sigma^+$-Baum für $\Sigma = \{a, \dots, g\}$}
\label{fig:SigmaPlusTree}
\end{figure}

\begin{definition}[Pfad]
\label{def:Pfad}
Die Funktion $path(k)$ bezeichnet die Konkatenation der Kantenbeschriftungen von der Wurzel bis zum Knoten $k$.
\end{definition}

Mithilfe der obigen Definition \ref{def:Pfad}, lässt sich eine elegante Notation für die Bezeichnung von Knoten eines $\Sigma^+$-Baumes einführen\footnote{Diese Notation wird in \cite{Ukkonen1995} eingeführt.}. Mit $\overline{w}$ bezeichnen wir genau dann einen Knoten $k$, wenn $path(k) = w$. Dieser Zusammenhang wird in Abb. \ref{fig:NotationZurKnotenbezeichnung} veranschaulicht.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 35mm},
    level 2/.style = {level distance = 10mm, sibling distance = 25mm},
    level 3/.style = {level distance = 10mm, sibling distance = 20mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch] {}
    child[child anchor = north] {
        node[subtree] {}
        edge from parent[dotted]
    }
    child {
        node[branch] {}
        child {
            node (n) [branch] {}
            child[child anchor = north] {
                node[subtree] {}
                edge from parent[dotted]
            }
            child[child anchor = north] {
                node[subtree] {}
                edge from parent[dotted]
            }
            edge from parent
            node[right] {$u$}
        }
        edge from parent
        node[left] {$v$}
    }
    child[child anchor = north] {
        node[subtree] {}
        edge from parent[dotted]
    };
    \node[left = 2mm] at (n) {$\overline{vu}$};
\end{tikzpicture}
\medskip
\caption{Notation zur Knotenbezeichnung}
\label{fig:NotationZurKnotenbezeichnung}
\end{figure}

Einen Knoten $\overline{w}$ nennen wir Verzweigung, wenn von ihm mehr als eine Kante ausgeht. Alle Kanten, die nicht zu einem Blattknoten führen, bezeichnen wir als innere Kanten eines Baumes. Ein Wort $w$ ist genau dann in einem $\Sigma^+$-Baum $T$ enthalten, wenn ein Knoten $\overline{wu}$ in diesem Baum existiert, d.h. $w$ ist Präfix eines Wortes, dass durch die Konkatenation der Kantenbeschriftungen eines Pfades in $T$ gebildet werden kann.

%////////////////////////////////////////////////////////////////////////////
\subsection{Suffix Tree Klassen}
\label{sec:suffixTreeKlassen}
%////////////////////////////////////////////////////////////////////////////

Zu Beginn dieses Abschnitts geben wir eine allgemeine Definition für Suffix Trees, die später durch den Begriff der Suffix Tree Klassen\footnote{Diese Art der Klassifizierung von Suffix Trees stammt aus \cite{Giegerich1995}.} weiter differenziert wird.

Suffix Trees bilden eine Teilmenge der $\Sigma^+$-Bäume. Analog zu anderen Suchbäumen ist auch der Aufbau des Suffix Tree durch die Anforderungen an die Suchoperation motiviert. Suffix Trees wurden primär für das Problem der exakten Teilwortsuche entwickelt, welches in Kapitel \ref{sec:Teilwortsuche} detailliert behandelt wird. Man nutzt hier die Tatsache, dass sich jedes Teilwort $w$ eines Wortes $t$ als Präfix eines Suffix darstellen lässt:
\begin{gather*}
    t = a \dots b \underbrace{\overbrace{c \dots d}^{\text{Präfix }w} e \dots f}_{\text{Suffix }s}
\end{gather*}
Somit kann das Problem der exakten Teilwortsuche auf eine Präfixsuche auf den Suffixen eines Wortes zurückgeführt werden. Diese Beobachtung führt zur zentralen Charakteristik von Suffix Trees, die in Abb. \ref{fig:suffixTreeAgcgacgag} leicht zu erkennen ist. Jeder Pfad von der Wurzel bis zu einem Blatt des Baumes korrespondiert mit einem Suffix des Wortes, für das der Suffix Tree aufgebaut wurde. Diese Überlegungen führen zu folgender formalen Definition für Suffix Trees.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 45mm},
    level 2/.style = {level distance = 10mm, sibling distance = 25mm},
    level 3/.style = {level distance = 10mm, sibling distance = 15mm},
    edge from parent/.style = {->, draw}
    ]
    \node[branch]{}
    child {
        node[branch]{}
        child {
            edge from parent
            node[left]{$cgag$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$gcgacgag$}
        }
        edge from parent
        node[above]{$a$}
    }
    child[level distance = 16mm] {
        node[branch]{}
        child {
            node[leaf] {}
            edge from parent
            node[left]{$cgag$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$g$}
        }
        edge from parent
        node[left]{$cga$}
    }
    child {
        node[branch]{}
        child {
            node[branch]{}
            child {
                node[leaf] {}
                edge from parent
                node[left]{$cgag$}
            }
            child {
                node[leaf] {}
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$a$}
        }
        child {
            node[leaf] {}
            edge from parent
            node[right]{$cgacgag$}
        }
        edge from parent
        node[above]{$g$}
    };
\end{tikzpicture}
\medskip
\caption{Suffix Tree für die Zeichenkette $agcgacgag$}
\label{fig:suffixTreeAgcgacgag}
\end{figure}

\begin{definition}[Suffix Tree\footnote{Auf diese Art und Weise werden Suffix Trees in \cite{Giegerich1995} definiert.}]
\label{def:SuffixTree}
Ein Suffix Tree $S_t$ für ein gegebenes Wort $t$ ist ein $\Sigma^+$-Baum, sodass gilt:
\begin{gather*}
    w \in S_t \Longleftrightarrow w \text{ ist ein }t\text{-Wort}
\end{gather*}
\end{definition}

Ausgehend von dieser allgemeinen Definition, werden Suffix Trees abhängig von der Anzahl ihrer Kanten nochmals in drei verschiedene Klassen unterteilt. Zur Unterscheidung dieser Klassen betrachten wir die Kantenmengen der Suffix Trees. Ein Suffix Tree $S_t$ für ein Wort $t$, repräsentiert durch seine Kantenmenge $E$ heißt
\begin{enumerate}
    \item Atomic Suffix Tree $ast$, wenn $\abs{E}$ maximal ist.
    \item Position Suffix Tree $pst$, wenn die Länge aller inneren Kantenbeschriftungen $1$ beträgt.
    \item Compact Suffix Tree $cst$, wenn $\abs{E}$ minimal ist
\end{enumerate}
Die drei Suffix Tree Formen stehen in Relation bezüglich Kantenverschmelzung.

\begin{definition}[Kantenverschmelzung]
Kantenverschmelzung ist eine Relation auf $\Sigma^+$-Bäumen, die durch ihre Kantenmengen repräsentiert werden.
\begin{gather*}
    \left(E \uplus \{\overline{s}\:\xrightarrow{u}\:\overline{w},\overline{w}\:\xrightarrow{u'}\:\overline{v}\}\right) \overset{\overline{w}}{\implies} \left(E \uplus \{\overline{s}\:\xrightarrow{uu'}\:\overline{v}\}\right)
\end{gather*}
wenn $\overline{w} \xrightarrow{u'} \overline{v}$ ist die einzige ausgehende Kante von $\overline{w}$. Die Umkehrrelation bezeichnen wir als Kantenteilung.
\end{definition}
Abb. \ref{fig:Kantenverschmelzung} zeigt, wie der Knoten $w$ mittels Kantenverschmelzung aus dem Baum entfernt wird. Es ist darauf zu achten, dass der Knoten $w$ keine Verzweigung ist.

Während $ast$ eine Normalform bezüglich Kantenteilung und $cst$ eine Normalform bezüglich Kantenverschmelzung darstellen, repräsentiert der $pst$ ein Hybridstadium zwischen $ast$ und $pst$. Abb. \ref{fig:SuffixTreeKlassen} zeigt alle drei Suffix Tree Klassen für diesselbe Zeichenkette $agcgacgag$.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 10mm, sibling distance = 40mm},
    level 2/.style = {level distance = 10mm, sibling distance = 30mm},
    level 3/.style = {level distance = 10mm, sibling distance = 20mm},
    edge from parent/.style = {->, draw}
    ]
    { [xshift = 0cm, yshift = 0cm]
        \node {}
        child {
            node[branch] (s1) {}
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            child {
                node[branch] (w1) {}
                child {
                    node[branch] (v1) {}
                    edge from parent
                    node[left]{$u'$}
                }
                edge from parent[solid]
                node[left]{$u$}
            }
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            edge from parent[dotted]
        };
    }
    \node[subtree] at (v1.center) {};
    \node[yshift = 2mm, xshift = 3mm] at (s1.center) {$\overline{s}$};
    \node[right] at (w1.east) {$\overline{w}$};
    \node[right] at (v1.center) {$\overline{v}$};
    { [xshift = 4cm, yshift = {-1cm}]
        \node{$\overset{\overline{w}}{\implies}$};
    }
    { [xshift = 8cm, yshift = 0cm]
        \node{}
        child {
            node[branch] (s2) {}
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            child[level distance = 12mm] {
                node[branch] (v2) {}
                edge from parent[solid]
                node[left]{$uu'$}
            }
            child[child anchor = north] {
                node[subtree]{}
                edge from parent[dotted]
            }
            edge from parent[dotted]
        };
    }
    \node[subtree] at (v2.center) {};
    \node[yshift = 2mm, xshift = 3mm] at (s2.center) {$\overline{s}$};
    \node[right] at (v2.center) {$\overline{v}$};
\end{tikzpicture}
\medskip
\caption{Kantenverschmelzung}
\label{fig:Kantenverschmelzung}
\end{figure}

\begin{figure}
\centering
\begin{tikzpicture}[
    font = \small,
    level 1/.style = {level distance = 7mm, sibling distance = 25mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [xshift = 0cm, yshift = 0cm]
        \node[branch] (root) {}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$c$}
                }
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    node[branch]{}
                                        child {
                                            node[branch]{}
                                            child {
                                                edge from parent
                                                node[left]{$g$}
                                            }
                                            edge from parent
                                            node[left]{$a$}
                                        }
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$c$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$c$}
                }
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[above]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    edge from parent
                                    node[left]{$g$}
                                }
                                edge from parent
                                node[left]{$a$}
                            }
                            edge from parent
                            node[left]{$g$}
                        }
                        edge from parent
                        node[left]{$c$}
                    }
                    child {
                        edge from parent
                        node[right]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$a$}
                        }
                        edge from parent
                        node[left]{$g$}
                    }
                    edge from parent
                    node[left]{$c$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        node[branch]{}
                        child {
                            node[branch]{}
                            child {
                                node[branch]{}
                                child {
                                    node[branch]{}
                                    child {
                                        edge from parent
                                        node[left]{$g$}
                                    }
                                    edge from parent
                                    node[left]{$a$}
                                }
                                edge from parent
                                node[left]{$g$}
                            }
                            edge from parent
                            node[left]{$c$}
                        }
                        edge from parent
                        node[left]{$a$}
                    }
                    edge from parent
                    node[left]{$g$}
                }
                edge from parent
                node[right]{$c$}
            }
            edge from parent
            node[above]{$g$}
        };
        \node[left = 2cm, yshift = 2mm] at (root) {$\boldsymbol{ast}$};
    }
    { [xshift = 8cm, yshift = 0cm]
        \node[branch] (root) {}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[branch]{}
                    child {
                        edge from parent
                        node[left]{$cgag$}
                    }
                    child {
                        edge from parent
                        node[right]{$g$}
                    }
                    edge from parent
                    node[left]{$a$}
                }
                edge from parent
                node[left]{$g$}
            }
            edge from parent
            node[left]{$c$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent
                    node[left]{$cgag$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
        \node[left = 2cm, yshift = 2mm] at (root) {$\boldsymbol{pst}$};
    }
    { [xshift = 8cm, yshift = -3.5cm]
        \node[branch] (root) {}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                node[leaf] {}
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 22mm] {
            node[branch]{}
            child {
                node[leaf] {}
                edge from parent
                node[left]{$cgag$}
            }
            child {
                node[leaf] {}
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left, yshift = -5mm]{$cga$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    node[leaf] {}
                    edge from parent
                    node[left]{$cgag$}
                }
                child {
                    node[leaf] {}
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                node[leaf] {}
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
        \node[left = 2cm, yshift = 2mm] at (root) {$\boldsymbol{cst}$};
    }
\end{tikzpicture}
\medskip
\caption{Suffix Tree Klassen: $ast$, $pst$ und $cst$ für die Zeichenkette $agcgacgag$}
\label{fig:SuffixTreeKlassen}
\end{figure}

%////////////////////////////////////////////////////////////////////////////
\subsection{Generalized Suffix Tree}
\label{sec:GeneralizedSuffixTree}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\section{Anwendungsgebiete}
\label{sec:Anwendungsgebiete}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\subsection{Überblick}
\label{sec:Ueberblick}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\subsection{Longest common substring}
\label{sec:longestCommonSubstring}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\section{Suffix Tree Konstruktion}
\label{sec:SuffixTreeKonstruktion}
%////////////////////////////////////////////////////////////////////////////

In diesem Abschnitt wird ein Algorithmus dargestellt, der einen kompakten Suffixbaum für ein Wort $t$ aufbaut. Es gibt zwei prinzipiell unterschiedlichen Ansätze dafür.

Erster Ansatz ist imperativ: sukzessive Einfügung der Suffixe von $t$ in einen Baum, der als leer initialisiert wird. Die Konstruktion wird erfolgen mittels Iterationen über das Wort $t$, indem Suffixe von links nach rechts (oder auch umgekehrt) jedes Mal abgelesen werden.

Zweiter Ansatz ist funktional: Der Baum wird rekursiv aufgebaut, indem zuerst Kanten vom Wurzel aufgebaut werden und dann für jeden Unterbaum das Verfahren wiederholt wird. Wichtig, dass bei diesem Verfahren keine Updates vom Baum benötigt sind.

TODO: ein Satz mit ''hier werden wir wotd anschauen''


%////////////////////////////////////////////////////////////////////////////
\subsection{WOTD-Algorithmus}
\label{sec:WOTDAlgorithmus}
%////////////////////////////////////////////////////////////////////////////

Schritte des Algorithmus:

\begin{enumerate}
    \item Erzeuge alle Suffixe eines gegebenen Wortes.
    \item Gruppiere nach den Anfangsbuchstaben. Erzeuge einen Knoten.
    \item Für jede Gruppe:
    \begin{enumerate}
        \item Berechne das längste gemeinsame Präfix, erzeuge eine Kante mit der Beschriftung vom Präfix, entferne das Präfix von den Wörtern der Gruppe.
        \item Falls die Gruppe von Restwörter leer ist, erzeuge ein Blatt. Falls es in der Gruppe noch Wörter gibt, kehre zu Schritt 2 zurück.
    \end{enumerate}
\end{enumerate}

Beispiel für das Wort $t$ = $agcgacgag$:
\begin{enumerate}
    \item Suffixliste: $agcgacgag$, $gcgacgag$, $cgacgag$, $gacgag$, $acgag$, $cgag$, $gag$, $ag$, $g$
    \item Gruppierungsschritt:
        \begin{center}
        \begin{tabular}{l l l}
            \toprule
            Gruppe 1                 & Gruppe 2               & Gruppe 3                \\
            \midrule
            $\boldsymbol{a}gcgacgag$ & $\boldsymbol{c}gacgag$ & $\boldsymbol{g}cgacgag$ \\
            $\boldsymbol{a}cgag$     & $\boldsymbol{c}gag$    & $\boldsymbol{g}acgag$   \\
            $\boldsymbol{a}g$        &                        & $\boldsymbol{g}ag$      \\
            \bottomrule
        \end{tabular}
        \end{center}
    \item Bestimmung des längsten gemiensamen Präfixes für jede Gruppe:
        \begin{center}
        \begin{tabular}{l l l}
            \toprule
            Gruppe 1                 & Gruppe 2               & Gruppe 3                \\
            \midrule
            $\boldsymbol{a}gcgacgag$ & $\boldsymbol{cga}cgag$ & $\boldsymbol{g}cgacgag$ \\
            $\boldsymbol{a}cgag$     & $\boldsymbol{cga}g$    & $\boldsymbol{g}acgag$   \\
            $\boldsymbol{a}g$        &                        & $\boldsymbol{g}ag$      \\
                                     &                        & $\boldsymbol{g}$        \\
            \midrule
            $a$                      & $cga$                  & $g$                     \\
            \bottomrule
        \end{tabular}
        \end{center}
    \item Rekursiv für jede Gruppe von Restwörter.
\end{enumerate}

Veranschaulichung der Phasen in Abb. \ref{fig:cstKonstruktion}

% [h]: here, [t]: top, [b]: bottom
\begin{figure}[h]
\centering
\begin{tikzpicture}[
    level 1/.style = {level distance = 7mm, sibling distance = 30mm},
    level 2/.style = {level distance = 7mm, sibling distance = 15mm},
    level 3/.style = {level distance = 7mm, sibling distance = 10mm},
    edge from parent/.style = {->, draw}
    ]
    { [yshift = 0cm]
        \node[branch]{}
        child {
            node[ghostbranch] (u) {}
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 8mm] {
            node[ghostbranch] (v) {}
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[ghostbranch] (w) {}
            edge from parent
            node[above]{$g$}
        };
        \node[align = left, anchor = north, yshift = {-1mm}] at (u.center) {$gcgacgag$ \\ $cgag$ \\ $g$};
        \node[align = left, anchor = north, yshift = {-1mm}] at (v.center) {$cgag$ \\ $g$};
        \node[align = left, anchor = north, yshift = {-1mm}] at (w.center) {$cgacgag$ \\ $acgag$ \\ $ag$};
    }
    { [yshift = -3cm]
        \node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 16mm] {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent
                    node[left]{$cgag$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
    }
    { [yshift = -6.5cm]
        \node[branch]{}
        child {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$gcgacgag$}
            }
            edge from parent
            node[above]{$a$}
        }
        child[level distance = 16mm] {
            node[branch]{}
            child {
                edge from parent
                node[left]{$cgag$}
            }
            child {
                edge from parent
                node[right]{$g$}
            }
            edge from parent
            node[left]{$cga$}
        }
        child {
            node[branch]{}
            child {
                node[branch]{}
                child {
                    edge from parent
                    node[left]{$cgag$}
                }
                child {
                    edge from parent
                    node[right]{$g$}
                }
                edge from parent
                node[left]{$a$}
            }
            child {
                edge from parent
                node[right]{$cgacgag$}
            }
            edge from parent
            node[above]{$g$}
        };
    }
\end{tikzpicture}
\medskip
\caption{cst-Konstruktion für $t$ = $agcgacgag$}
\label{fig:cstKonstruktion}
\end{figure}


%////////////////////////////////////////////////////////////////////////////
\subsection{Implementierung in Haskell}
\label{sec:ImplementierungInHaskell}
%////////////////////////////////////////////////////////////////////////////

Zuerst werden benötige Datentypen beschrieben. Ein Baum ist entweder ein Blatt oder eine Verzweigung. Eine Verzweigung ist eine Liste von Tupeln, wobei erstes Element vom Tupel eine Kante (also, eine Kantenbeschriftung) ist, und zweites Element ist der Unterbaum, der von der Kante ausgeht. $alf$ ist Typparameter vom Alphabet, $Label\:alf$ ist ein Liste von Elementen des Alphabets.
Typ der EdgeFunktion bedeutet, dass man eine Liste von Wörter nimmt und auf ein Tupel abbildet, wobei erstes Element vom Tupel das längste gemeinsame Präfix der Wörter ist und zweites Element eine Liste von Wörter, von denen das längste gemeinsame Präfix entfernt wurde. Implementierung:

\begin{lstlisting}[
    caption = Typdefinitionen,
    label = lst:typdefinitionen,
    captionpos = b,
    float = hb
    ]
-- | Darstellung von Suffix Trees
data STree alf = Leaf | Branch [(Label alf, STree alf)] deriving Eq

-- | Darstellung von Beschriftungen
type Label alf = [alf]

-- | Darstellung vom Kantenaufbau
type EdgeFunction alf = [[alf]] -> ([alf], [[alf]])
\end{lstlisting}

Auswahl einer Gruppe, die mit einer Buchstabe anfängt, die im Parameter $a$ gebunden ist:

Die folgende Funktion bestimmt das längste gemeinsame Präfix für eine Gruppe der Wörter. Die Gruppe wird als Eingabeliste übergeben. Zuerst wird geprüft, ob alle Wörter mit der gleichen Buchstabe anfangen. Falls es der Fall ist, dann wird die Buchstabe an $cp$ angehängt und eine neue Liste ohne das erste Buchstabe erzeugt. Falls ein Wort sich endet, dann wird es weggelassen. Die Fkt terminiert falls es nur ein Wort in der Gruppe bleibt oder wenn nicht alle Restwörter in der Gruppe mit der gleichen Buchstabe anfangen. Die Funktion gibt ein Tupel zurück, wobei erstes Element vom Tupel das längste gemeinsame Präfix der Wörter in der Eingabeliste ist und zweites Element eine Liste von restlichen Wörter, von denen das längste gemeinsame Präfix entfernt wurde. Implementierung:

Nächste Funktion setzt die oben besprochene Funktionen zusammen und erzeugt den kompletten Baum. Als Eingabe wird die Funktion $edge$, einen Alphabet des gegebenen Wort in der Form einer Liste von Buchstaben und ein Wort t, für das Siffixbaum aufgebaut werden soll, gegeben. Die Suffixliste von $t$ wird an einer Hilfsfunktion $sTr$ geliefert, die den Baum wie folgt rekursiv aufbaut:

    - Wenn die Suffixliste leer ist, dann wird ein Blatt erstellt.

    - Wenn die Suffixliste nicht leer ist, dann eine Verzweigung.

Verzweigung besteht aus Tupeln, die in der esten Komponente das längste gemeinsame Präfix von jeder Gruppe als Kantenbeschriftung und einen entsprechenden Unterbaum in der zweiten Komponente enthalten. Der entsprechende Unterbaum wird rekursiv erzeugt.

Die Kantenliste wird aufgebaut, indem:
\begin{enumerate}
    \item Jede Buchstabe des Alphabets an der Variable $a$ gebunden wird.
    \item Die entsprechende Liste durch den Aufruf der Funktion select an die Variable $gs$ gebunden wird.
    \item Falls die Gruppe nicht leer ist, wird durch den Aufruf von $edge$ das gemeinsame Präfix und die Liste von Restwörter berechnet.
\end{enumerate}
Implementierung:
\begin{lstlisting}[
    caption = Algorithmus zur Suffix Tree Konstruktion,
    label = lst:AlgorithmusZurSuffixTreeKonstruktion,
    captionpos = b,
    float = htb
    ]
-- | Liefert eine Liste aller Suffixe eines gegebenen Wortes
suffixes :: [alf] -> [[alf]]
suffixes []       = []
suffixes aw@(_:w) = aw:suffixes w

-- | Liefert alle Woerter mit Anfangsbuchstaben a
select :: (Eq alf) => [[alf]] -> alf -> [[alf]]
select ss a = [c:u | c:u <- ss, a == c]

-- | Funktion zur Kantenerzeugung
edge :: (Eq alf) => EdgeFunction alf
edge [s] = ([s], [[]])
edge awss@((a:_):ss) | all (\c:_ -> a == c) ss = (a:cp, rss)
                     | otherwise               = ([], awss)
                     where (cp, rss) = edge ([t | _:t <- awss, length t > 0])

-- | Konstruktion des Suffix Trees
lazy_cst ::(Eq alf) => (EdgeFunction alf) -> [alf] -> [alf] -> STree alf
lazy_cst edge alpha t = sTr (suffixes t)
    where
    sTr [[]] = Leaf
    sTr ss   = Branch[(cp,sTr rss) | a <- alpha,
                                     let gs = select ss a,
                                     length gs > 0,
                                     let (cp,rss) = edge gs]
\end{lstlisting}

%////////////////////////////////////////////////////////////////////////////
\subsection{Laufzeitanalyse}
\label{sec:Laufzeitanalyse}
%////////////////////////////////////////////////////////////////////////////

Um die Laufzeit von dem gesamten Algorithmus zu betrachten, wird zuerst die Kostenabschätzung von der Funktion $edge$ bestimmt, weil diese Funktion die höchste Laufzeitkomplexität besitzt.

Die Kostenfunktion für $edge$ ist von zwei Parameter abhängig: die Länge der Wörterliste und die Länge des gemeinsamen Präfix dieser Wörter. Die Funktion wird so oft rekursiv aufgerufen wie die Länge des gemeinsamen Präfix von der gegebenen Wörterliste ist. In jedem Aufruf von $edge$ werden zwei andere Funkrionen aufgerufen, deren Laufzeit von der Länge der Eingabeliste linear abhängig ist. Eine der Funktionen ist lambda-Ausdruck, wir haben zur Vereinfachung sie als $isEqual$ bei der Laufzeitanalyse bezeichnet. Zweite Funktion ist als List-comprehension gegeben, sie wird als $newList$ bezeichnet.

Die Kosten der Funktion $edge$ setzen sich zusammen aus den Kosten der Fkt $isEqual$ für $n - 1$, den Kosten der Funktion $newList$ für $n$ und den Kosten des rekursiven Aufrufs von $edge$ für $n - 1$ und $\abs{cp} - 1$.

Insgesamt:
\begin{align*}
    T(n,\abs{cp}) &= isEqual(n - 1) + newList(n) + T(n-1,\abs{cp}-1) \\
                  &= \sum_{i = 1}^{\abs{cp}}{isEqual(n-1)} + \sum_{i = 1}^{\abs{cp}}{newList(n)}\\
                  &= \abs{cp} (n - 1) + \abs{cp} n \in O(\abs{cp} \cdot n)
\end{align*}

Weiter wird das worst-case vom WOTD-Algoritmus bestimmt. Dieses produziert z.B. das Wort $a^n$, indem es als der Parameter $t$ an der Funktion $lazy\_cst$ gegeben wird. Zuerst wird $sTr$ mit $ss = [a^n,\:a^{n-1}, \dots ,\:a]$ aufgerufen, dann wird dem Parameter $gs$ komplette Liste $ss$ zugewiesen und die Funktion $edge$ mit dem Parameter $gs$ aufgerufen. Die Funktion $edge$ liefert das Ergebnis $(cp,rss) = (a^n, [[\:]])$. Weiter wird $sTr$ mit mit dem Parameter $rss = [[\:]]$ aufgerufen und damit terminiert die Funktion $lazy\_cst$. Weil $|cp| = n$, ist die Laufzeit von $edge$ und von dem gesamten Algorithmus $O(n^2)$.

%////////////////////////////////////////////////////////////////////////////
\section{Teilwortsuche}
\label{sec:Teilwortsuche}
%////////////////////////////////////////////////////////////////////////////

Zum Abschluss des Kapitels möchten wir zeigen, dass mit dem erzeugten Suffixbaum kann man nicht nur Suffixe effezient suchen, sondern auch Teilwörter vom gegebenen Wort. Dafür definieren wir eine Hilfsfunkktion, die ähnlich wie die $edge$-Funktion arbeitet:

Die Funktion bestimmt das längste gemeinsame Präfix von zwei Wörter und liefert zurück ein Tripel $(w1',\: w2',\: cp)$, wobei $cp$ das längste gemeinsame Präfix ist, $w1'$ und $w2'$ sind Ergebnisse der Entfernung $cp$ von $w1$ bzw. $w2$.

Die tatsächliche Teilwortsuche haben wir mit der Funktion $search$ gelöst:

\begin{lstlisting}[
    caption = Suche im Suffix Tree,
    label = lst:SucheImSuffixTree,
    captionpos = b,
    float = hb
    ]
commonPrefix :: (Eq alph) => Word alph -> Word alph -> (Word alph, Word alph, Word alph)
commonPrefix w1 w2 = g w1 w2 []
    where g (x:xs) (y:ys) cp | (x == y) = g xs ys (x:cp)
          g w1 w2 cp  = (w1, w2, reverse cp)

search :: (Eq alph) => Word alph -> STree alph -> Bool
search ss Leaf        = False
search ss (Branch es) =  g ss es
    where
    g ss [] = False
    g ss (((l, st):es)) =
        case commonPrefix ss l of
         ([], _, _)   -> True          -- ss ist leer
         (_, _, [])   -> g ss es       -- falsche Kante
         (ss', [], _) -> search ss' st -- richtige Kante
         _            -> False         -- cp != []|l|ss
\end{lstlisting}

Die Eingabe ist ein Teilwort und ein Baum, wo das Teilwort gesucht werden muss. Die Funktion erledigt die Suche wie folgt:

    - Falls der Baum leer ist, dann ist die Suche nicht möglich.

    - Falls der Baum eine Verzweigung ist, dann wird eine Hilfsfunktion $g$ mit dem gesuchten Wort und der Liste von Kanten aufgerufen.

Fallunterscheidung der Funktion $g$:
\begin{enumerate}
    \item Wenn die Liste von Kanten leer ist, dann ist das Wort im Baum nicht enthalten.
    \item Im anderen Fall suchen wir die passende Kante indem wir das gemeinsame Präfix des gesuchten Wortes und jeweilige Kante berechnen. Das wird mit der Fkt $commonPrefix$ gemacht. Wenn das gesuchte Wort und jeweilige Kante kein gemeinsames Präfix haben, dann gehen wir zu der nächste Kante $\rightarrow$ der Fall $falsche$ $Kante$.
    \item Wenn es keine Kanten mehr gibt, dann ist das gesuchte Teilwort nicht im Baum enthalten $\rightarrow$ der Fall $g$ $ss$ $[\:]$ $=$ $False$.
    \item Wenn das gesuchte Teilwort und die Kante das gemeinsame Präfix haben, dann müssen drei Fälle betrachtet werden:
    \begin{enumerate}
        \item Die Kante ist ein Teil von dem gesuchten Teilwort $\rightarrow$ der Fall $richtige$ $Kante$.
        \item Das gesuchte Teilwort ist ein Teil von der Kantenbeschriftung $\rightarrow$ der Fall $ss$ $ist$ $leer$.
        \item Das gemeinsame Präfix ist nicht leer, aber enthält weder komplette Kantenbeschriftung, noch das komplette gesuchte Wort $\rightarrow$ der Fall $cp\:!=\:[\:]\mid l \mid ss$.
    \end{enumerate}
\end{enumerate}

%////////////////////////////////////////////////////////////////////////////
\chapter{Suffix Array}
\label{sec:SuffixArray}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\section{Motivation}
\label{sec:Motivation}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\section{Terminologie}
\label{sec:SuffixArrayTerminologie}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
\section{DC3-Algorithmus}
\label{sec:DC3Algorithmus}
%////////////////////////////////////////////////////////////////////////////

%////////////////////////////////////////////////////////////////////////////
% Literaturverzeichnis
%////////////////////////////////////////////////////////////////////////////

\bibliography{refs}
\nocite{*}

\end{document}